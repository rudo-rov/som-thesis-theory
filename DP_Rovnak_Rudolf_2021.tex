% arara: xelatex
% arara: xelatex
% arara: xelatex


\documentclass[thesis=M,english]{FITthesis}[2019/12/23]

%\usepackage[utf8]{inputenc} % LaTeX source encoded as UTF-8
% \usepackage[latin2]{inputenc} % LaTeX source encoded as ISO-8859-2
% \usepackage[cp1250]{inputenc} % LaTeX source encoded as Windows-1250

% \usepackage{subfig} %subfigures
% \usepackage{amsmath} %advanced maths
% \usepackage{amssymb} %additional math symbols

\usepackage{dirtree} %directory tree visualisation
\usepackage{hyperref}
\usepackage{url}
% \usepackage{svg}
\usepackage{lscape}
\usepackage{rotating}
\input{smalltalkEnv.tex}

% % list of acronyms
% \usepackage[acronym,nonumberlist,toc,numberedsection=autolabel]{glossaries}
% \iflanguage{czech}{\renewcommand*{\acronymname}{Seznam pou{\v z}it{\' y}ch zkratek}}{}
% \makeglossaries

\department{Department of Theoretical Computer Science}
\title{SimpleObjectMachine implementation}
\authorGN{Rudolf} %author's given name/names
\authorFN{Rovňák} %author's surname
\author{Rudolf Rovňák} %author's name without academic degrees
\authorWithDegrees{Bc. Rudolf Rovňák} %author's name with academic degrees
\supervisor{Ing. Petr Máj}
\acknowledgements{THANKS (remove entirely in case you do not with to thank anyone)}
\abstractEN{In this work I provide an implementation of a virtual machine for Simple Object Machine programming language, based on Smalltalk.
	Additionally, I will provide an analysis of existing implementations, along with an analysis of my own. I will design and implement a parser,
	bytecode with a compiler and runtime environment with garbage collector to allow executing programs written in SOM.}
\abstractCS{V tejto pr{\' a}ci vytvor{\' i}m implement{\' a}ciu virtu{\' a}lneho stroja pre programovac{\' i} jazyk Simple Object Machine, zalo{\v z}enom na Smalltalku.
	Takisto vypracujem anal{\' y}zu existuj{\' u}cich rie{\v s}en{\' i} a anal{\' y}zu vlastn{\' e}ho rie{\v s}enia. Navrhnem a implementujem syntaktick{\' u} anal{\' y}zu,
	bajtk{\' o}d s procesom kompil{\' a}cie do{\v n} a prostredie pre spustenie programov nap{\' i}san{\' y}ch v programovacom jazyku SOM.}
\placeForDeclarationOfAuthenticity{Prague}
\keywordsCS{Replace with comma-separated list of keywords in Czech.}
\keywordsEN{runtime, virtual machine, }
\declarationOfAuthenticityOption{1} %select as appropriate, according to the desired license (integer 1-6)
% \website{http://site.example/thesis} %optional thesis URL


\begin{document}

% \newacronym{CVUT}{{\v C}VUT}{{\v C}esk{\' e} vysok{\' e} u{\v c}en{\' i} technick{\' e} v Praze}
% \newacronym{FIT}{FIT}{Fakulta informa{\v c}n{\' i}ch technologi{\' i}}

% \setsecnumdepth{part}
\setcounter{secnumdepth}{3}
\chapter{Introduction}
In the last decades, a trend of dynamic programming languages \footnote{Not to be confused with \textit{dynamically typed programming languages.}} has been on the rise.
As opposed to static programming languages (usually compiled) dynamic ones offer a higher level of abstraction and allow faster and less error-prone development.
Dynamic languages move a lot of actions traditionally done during compile-time to run-time. This creates the need for another layer, \textit{a runtime environment}.

My goal in this diploma thesis is to implement a process virtual machine for a programming language called SOM, or Simple Object Machine. 
It is a dynamic, object-oriented programming language based on Smalltalk. It was originally implemented at University of Århus in Denmark to teach
object oriented VMs \cite{som-github}. There are several implementations in various programming languages, ranging in speed, optimizations etc.

My main focus in my work will be the clarity of implementation over performance. I will try to provide a basic implementation of a traditional runtime
VM that can be built upon in the future. This will include the process of parsing, compiling the bytecode and then providing a runtime environment,
along with an implementation for most basic principles (flow control, basic data types, loops).

\chapter{Analysis and design}
\textit{Simple Object Machine} (SOM) is a minimal Smalltalk dialect used primarily for teaching construction of virtual machines. Key characteristics
according to official website (\cite{som-github}) are:
\begin{itemize}
	\item clarity of implementation over performance,
	\item common language features such as: objects, classes, closures, non-local returns
	\item interpreter optimizations, threading, garbage collectors are different
		across various implementations.
\end{itemize}

\section{Existing implementations}
There are multiple existing implementations of SOM written in different programming languages, including: Java (SOM), C (CSOM) C++ (SOM++), Python (PySOM) and
many others. Some of these are bytecode based, others utilize abstract syntax tree interpretation. They range in implemented optimizations (CSOM offers no 
optimizations, while TruffleSOM claims to be highly optimised).

Additionally, Read-Eval-Print loop implementation is available on the official site of the project. The REPL accepts only simple expressions and does
not support class definitions. Standard library is available. \cite{som-github}

\section{Grammar}
To implement a parser for the language, I decided to use ANTLR. I will demonstrate language features and design on the following ANTLR grammar
for SOM. For the sake of brevity, I ommited terminal symbols from the complete grammar as they are self-explanatory. All the terminal symbols
in this grammar are named in uppercase letters.

\begin{verbatim}
	grammar SOM;

	classDefinition:
		IDENTIFIER EQUALS superclass
		instanceFields method*
		(SEPARATOR classFields method*) ?
		CLOSE_PAR
	;
	superclass: IDENTIFIER? OPEN_PAR;
	instanceFields: (VBAR variable* VBAR)?;
	classFields: (VBAR variable* VBAR)?;
	method: pattern EQUALS methodBlock;
	methodBlock: OPEN_PAR blockContents? CLOSE_PAR;
	blockContents:
		(VBAR localDefinitions VBAR)?
		blockBody;
	localDefinitions: variable*;
	blockBody: 
		  RETURN result
		| expression (PERIOD blockBody?)?;
	result: expression PERIOD?;
	expression: assignation | evaluation;
	assignation: assignments evaluation;
	assignments: assignment+;
	assignment: variable ASSIGN;
	evaluation: primary messages?;
	primary: variable | nestedTerm | nestedBlock | literal;
	messages:
		  unaryMessage+ binaryMessage* keywordMessage?
		| binaryMessage+ keywordMessage?
		| keywordMessage;
	unaryMessage: IDENTIFIER;
	binaryMessage: binarySelector binaryOperand;
	binaryOperand: primary unaryMessage*;
	keywordMessage: (KEYWORD formula)+;
	formula: binaryOperand binaryMessage*;
	nestedTerm: OPEN_PAR expression CLOSE_PAR;
	nestedBlock:
		NEW_BLOCK blockPattern? blockContents? CLOSE_BLOCK;
	blockPattern: blockArgs VBAR;
	blockArgs: (COLON argument)+;
	variable: IDENTIFIER;
	pattern: unaryPattern | keywordPattern | binaryPattern;
	unaryPattern: unarySelector;
	unarySelector: IDENTIFIER;
	binaryPattern: binarySelector argument;
	keywordPattern: (KEYWORD argument)+;
	binarySelector: 
		VBAR | PLUS | MINUS | EQUALS | MULT | DIV | MOD |
		GREATER | GREATER_EQ | LESS | LESS_EQ;
	argument: variable;
	literal: literalNumber | literalString | literalArray | literalSymbol;
	literalNumber: MINUS? (INTEGER | DOUBLE);
	literalString: STRING;
	literalArray: POUND NEW_BLOCK literal* CLOSE_BLOCK;
	literalSymbol: POUND (STRING | selector);
	selector: binarySelector | keywordSelector | unarySelector;
	keywordSelector: KEYWORD+;
\end{verbatim}

\section{Class definition}
\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{media/grammar/classDefinition_rrd.png}
	\caption{Railroad diagram for \texttt{classDefinition} rule.}
	\label{fig:classDefinition_rrd}
\end{figure}

\begin{figure}[h!]
\begin{lstlisting}[language=Smalltalk]
	SimpleHello = (
		| name |

		setName: aString (
			name := aString
		)

		printGreeting (
			('Hello, ', name) print
		)
	)
\end{lstlisting}
\caption{Example of a simple class defined in SOM.}
\label{fig:hello_example}
\end{figure}

Syntax for class definition follows the official SOM grammar. The language supports single inheritance as apparent from the use
of \texttt{subclass} token in the grammar. Not every class has explicitly specified superclass, therefore the actual identifier in
the rule is optional.

Declaration of instance side fields follows, denoted by vertical bars. This token itself can be empty. Instance side methods definitions
are next. Further details on \textit{methods} and \textit{messages} in SOM are discussed in TODO. % TODO: add a link to section on methods
Same syntax is used for class side fields and methods separated by a special token.

\subsection{Variables}
In Smalltalk, a variable is defined as \textit{``a dynamically modifiable association (binding) of either a name
or an index to a value. Each distinct variable has exactly one name (or index)''}\cite{smalltalk-essentials}.

A value of a named variable can be any object. Indexed variables are at the core also just an object. They
represent an ordered sequence of objects as a single value. Example of those are arrays or Strings. Actual
indices are always strictly positive (greater than zero), meaning the first element of an array corresponds
to index of value one. This is standard in Smalltalk dialects, although uncommon in C-like languages. Retrieving
the values belonging to an index is done via sending a message to the encapsualting object.

When creating a new variable, it is assigned a special value \texttt{nil}, meaning the variable is empty. This
special value can also be explicitly assigned to a variable at any point.

SOM is a dynamically typed programming language (as is Smalltalk). As a result, there is no syntax to indicate
a data type of a variable. One thing worth pointing out is that in the context of Smalltalk, a \textit{data type}
is defined differently than most programming languages. As stated in \cite{smalltalk-essentials}, a class is not
a type. A Smalltalk type is defined as \textit{``the power set of messages to which an object can meaningfully
respond''}\cite{smalltalk-essentials}. This is the definition I will be using in the context of SOM. As a result
of this, any number of SOM classes can implement one data type.

\subsubsection{Variable name scoping}
Every variable has its scope, which determines the visibility of the variable. SOM follows the rules of Smalltalk
when it comes to scoping, as defined in \cite{smalltalk-essentials}:

\begin{itemize}
	\item \textbf{Local variables} are accessible within the method or code block in which they are defined.
	\item \textbf{Formal method arguments} are accessible by the method wherein they are defined.
	\item \textbf{Formal block arguments} are accessible by the block wherein they are defined.
	\item \textbf{Instance variables} are accessible within all methods of a given object. Each object
		has its own instances of these variables.
	\item \textbf{Class variables} are accessible by all objects that are instances of the class or its
		subclasses. All the objects share the same instance of this variable.
	\item \textbf{Global variables} are accessible everywhere. These are primarily special variables
		(such as \texttt{nil}). Users cannot define their own global variables. This functionality can be
		achieved using class variables.
\end{itemize}

There is some more details on variable scoping, especially when talking about block closures. Further detail
is discussed in \ref{subsection:nlret}.

\subsection{Literals}
Outside of variables, there is also a need to represent fixed values in a SOM source code. 

\textbf{Integer literal} specifies a value of a decimal whole number, positive or negative.
In my implementation, every integer literal is a representation of an object of class \texttt{Integer}. 
To achieve simple manipulation with integer numbers, all integers are internally represented by a C++
data type \texttt{\detokenize{int32_t}} -- therefore 32 bit signed integer number. Overflow and underflow is not
addressed in my implementation, therefore the behaviour copies that of the underlying C++ type.

\textbf{Floating point literal} approximates a value of a real number. Syntactically, it consists of
a decimal, possibly negative, integer literal representing the non-fractional part of the number. It is
followed by a decimal point and another decimal (non-negative) integer representing the fractional part
of the number. Precision is implicitly given and there is no way to change it. My implementation uses
double precision (as defined in C++). Edge cases (such as rounding errors) are not addressed -- the behaviour
copies that of standard C++ double data type.

\textbf{String literal} represents a sequence of characters. String literals are objects of class \texttt{String}.
Syntactically, they are delimited by single quotes (\texttt{'}). To include a single quote in a string, it needs
to be escaped by another single quote.

In the provided implementation of SOM, String objects are not treated as a collection. It is an encapsulated object
and every String object is unmutable. Every message, that somehow uses and modifies the value of its receiver
creates a new object. This behaviour corresponds with Smalltalk and other SOM implementations.

\textbf{Array literals} specify a sequence of values encapsulated by a single object (that is an instance of class
\texttt{Array}). Syntactically, the values of an array are surrouned by parentheses and preceeded by a hash sign.
Note that because of the dynamic typing, elements of an array do not have to be instances of the same class.

Every Array literal results in an Array object instantiation. Arrays are mutable, unlike Strings.

\section{Primitives}
Even though SOM is purely object oriented, in order to get any actual computations done, there is a point where
some virtual machine primitives must be invoked. Following things are therefore implemented as primitives:
\begin{itemize}
	\item memory allocation (\texttt{new} message),
	\item bitwise operations,
	\item integer arithmethics (\texttt{+}, \texttt{-}, \texttt{=} etc.),
	\item array accessing (\texttt{at:}, \texttt{at:put:})
\end{itemize}

Primitives are implemented directly in the VM runtime, though not breaking the syntax or core principles of the
language. Details on implementation are in section \ref{subsection:primitives}.

\section{Methods and messages}
As the SOM language is based on Smalltalk, the concept of messages (and the link to methods) is crucial to understand.
\textit{``The only way to invoke a method is to send a message -- which necessarily involves dynamic binding
(by name) of message to method at runtime (and never at compile time). The internals of an object are not
externally accessible, ever -- the only way to access or modify an object's internal state is to send it
a message''} \cite{smalltalk-essentials}.

Execution of an invoked method ends with the execution of the last expression in it. Every method implicitly
returns \texttt{self} (a reference to the object on which the method is invoked). Explicit return of a value
is done with a special token \texttt{\^}. Execution of an expression preceeded by this token will exit the method.

The \cite{pharo-by-example} defines a helpful terminology for message passing:
\begin{itemize}
	\item A message is composed of the message \textit{selector} and the optional message arguments.
	\item Every message must be sent to its \textit{receiver}.
	\item Message and its receiver together will be referred to as \textit{message send}.
\end{itemize}

There are three types of messages (as defined in other Smalltalk dialects, Pharo as an example of one).

\textbf{Unary messages} are sent to an object without any additional information (argument). In the following
example, a unary message \texttt{size} is sent to a string object.
\begin{figure}[h!]
\begin{lstlisting}[language=Smalltalk]
	'hello' size "Evaluates to 5"
\end{lstlisting}
\caption{Unary message example.}
\end{figure}

\textbf{Binary messages} are a special type of messages that require exactly one argument. The selector
of a binary message can only consist of a sequence of one or more characters from the set: +, -, *, /,
\&, =, \textless, \textgreater, |, ~ and @. A very simple example of usage of binary messsage are arithmetic operations.
\begin{figure}[h!]
\begin{lstlisting}[language=Smalltalk]
	3 + 4 "Evaluates to 7"
\end{lstlisting}
\caption{Binary message example.}
\end{figure}

\textbf{Keyword messages} require one or more arguments. From the syntactic standpoint, they consist of
multiple keywords, each ending in colon (:). When sending a message, each keyword is followed by an argument.
Note, that a keyword message taking one argument is different to a binary message.
\begin{figure}[h!]
\begin{lstlisting}[language=Smalltalk]
	| numbers |
	numbers := #(1 2 3 4 5). "Simple array"
	"Sending a keyword message at:put: to an object of class Array"
	numbers at: 1 put: 6 "numbers is now #(6 2 3 4 5)"
\end{lstlisting}
\caption{Array example.}
\end{figure}

When composing messages of various types, there are precedence rules (as defined for Pharo in \cite{pharo-by-example}):
\begin{itemize}
	\item Unary messages are sent first, followed by binary messages. Keyword messages are sent last.
	\item Messages in parentheses are sent before other messages.
	\item Messages of the same kind are evaluated from left to right. 
\end{itemize}

These simple rules permit a very natural way of sending messages, as demonstrated on the next example.
First, a simple array is created. Then, a unary message \texttt{last} is evaluated, returning the last
element of the array. After that, binary message \texttt{+} is evaluated (to 2 in this example). Finally,
keyword message \texttt{at:put:} is sent to an array, putting number 5 on the second position in an array.
\begin{figure}[h!]
\begin{lstlisting}[language=Smalltalk]
	| numbers |
	numbers := #(1 2 3 4 5).
	numbers at: 1 + 1 put: numbers last.
	"numbers at: (1 + 1) put: (numbers last)"
\end{lstlisting}
\caption{Demonstration of message precedence.}
\end{figure}

Next example demonstrates sending messages from left to right when all of them are of the same type.
\begin{figure}[h!]
\begin{lstlisting}[language=Smalltalk]
	| numbers |
	numbers := #(1 2 3 4 5)
	numbers last asString print
	"This is equivalent to the following message sends"
	((numbers last) asString) print
\end{lstlisting}
\caption{Demonstration of message sends order for one message type.}
\end{figure}

There is a downfall to the simplicity of these rules. Arithmethic operations are all just a simple binary
message sends, therefore to ensure proper precedence, it is necessary to use parentheses.
\begin{figure}[h!]
\begin{lstlisting}[language=Smalltalk]
	"Evaluated as (3 + 2) * 5
	3 + 2 * 5
	"Parentheses required to achieve mathemathical
	operators precedence"
	3 + (2 * 5)
\end{lstlisting}
\caption{Demonstration of mathemathical operators precedence rules.}
\end{figure}

\section{Blocks}
Blocks provide a mechanism to defer the execution of expressions \cite{pharo-by-example}.
Blocks can be treated as an object -- they can be assigned to variables and
passed as arguments. 

Blocks can also accept parameters -- they are denoted with a leading colon. Parameters are separated from the body
of the block by a vertical bar. Local variables can also be declared inside a block. Those are accessible only inside
the block and are initialized each time a block is evaluated.

Block is executed by sending it a message \texttt{value}. However, this is a unary message and there is no way
to pass parameters to a block. To solve this problem, a keyword message \texttt{value:} is implemented. So far, this
gives a user to pass only one parameter to a block. To mitigate this issue, there are two posibilities. The first one
is to implement a keyword message for every number of parameters (for example \texttt{value:value:}, 
\texttt{value:value:value:}). While this approach is simple, readable and relatively easy to implement for low
numbers of parameters, it is impossible for this solution to be exhaustive and the code using very long keyword
messages would be bloated.

Another approach would be to implement a keyword message \texttt{value:} with an argument of array type. This would
permit to use arbitrary number of arguments, though it would require to create arrays of objects before passing them
to a block, which could impact readability and clarity of the code. In order to combine pros and cons of these 2
approaches, I have decided to follow the implementation in Pharo according to \cite[p.~65]{pharo-by-example}. 
There are keyword methods implemented for up to four parameters (\texttt{value:}, \texttt{value:value:}). For more
than four parameters, a special keyword message \texttt{valueWithArguments:} is implemented, where an array of
parameters is expected.

\begin{figure}[h!]
	\caption{Example of blocks usage in SOM.}
	\begin{lstlisting}[language=Smalltalk]
		| b0 b1 b2 b3 |
		b0 := [ 1 + 2 ].
		b1 := [ :x | x * x ].
		b2 := [ :x :y | x * y ].
		b3 := [ :x :y :z | x + y + z ].
		"Evaluating the blocks"
		b0 value. "Returns 3"
		b1 value: 3. "Returns 9"
		b2 value: 2 value: 8. "Returns 16"
		"Message valueWithArguments: can be used with 
		any number of parameters"
		b3 valueWithArguments: #(1 2 3). "Returns 6"
		"The next expression is functionally 
		identical to the previous one"
		b3 value: 1 value: 2 value: 3.
	\end{lstlisting}
\end{figure}

\subsection{Non--local return and block scoping}
\label{subsection:nlret}
Block closures are an essential feature to SOM. They allow the implementation of conditionals and loops as messages
rather then them being baked in the language syntax. Blocks however bring some dynamic runtime semantics that is not
straightforward. When used to the extreme, blocks can introduce some confusion and generally ugly code. However when
used correctly, they offer great way to improve readability and reusability of the code.

Every method has its defined context -- a set of variables and objects accessible from the method at given point in an
execution. Variables accessible by blocks are bound during runtime, in the context of where the block is \textit{defined},
rather than executed. This is reflected in creation and handling of frames (which can be considered a representation of
the context of given method). This also ties in to how returns from blocks function.

The context in which the block is created (and evaluated) is commonly called as \textit{home context} of the block.
The block home context is basically a representation of a particular point in the program execution. When a return
statement is executed, the execution steps out of the current context and returns to the caller. This can be
an implicit return (every method or block implicitly returns the receiver of the message). User can decide to
return a different value, denoted by explicit return statement, (\texttt{\^} token).

The behaviour of explicit return in blocks is where the term non--local return comes in. \textit{Non local return returns
to the sender of the block home context, i.e., to the method execution point that called the one that created the block}
\cite{pharo-blocks}. The important thing is that the home context is tied to the creation of the block, not its
evaluation. The pitfall here is there can be a situation where home context of a block being evaluated could end before
the block attempts a return to it. This will result in runtime error.

Consider the example on figure \ref{fig:nlreturn_1}.

\begin{figure}[h!]
	\centering
	\begin{lstlisting}[language=Smalltalk]
		NLReturn = (
			run = (
				| x |
				x := 0.
				[ x < 5 ] whileTrue: [
					x printLn.
					x := x + 1.
				]
			)
		)
	\end{lstlisting}
	\caption{Example to demonstrate non local return.}
	\label{fig:nlreturn_1}
\end{figure}

In the run method, a local variable \texttt{x} is created, than assigned an Integer of value 0. Then a loop is
executed. To better understand the example, figure \ref{fig:block_whileTrue} shows the implementation of method \texttt{whileTrue:} in a
\texttt{Block} class.

\begin{figure}[h!]
	\centering
	\begin{lstlisting}[language=Smalltalk]
		Block = (
			whileTrue: aBlock = (
				self value ifFalse: [ ^nil ].
				block value.
				self restart.
			)
		)
	\end{lstlisting}
	\caption{Implementation of \texttt{whileTrue:} method in \texttt{Block} class.}
	\label{fig:block_whileTrue}
\end{figure}

As apparent from the two examples, there are multiple blocks used and non local returns are crucial to achieve the functionality of the loop
(as implemented). The method \texttt{restart} is a primitive block method. It could be considered a jump -- it jumps to the begining of the current
context. The details of this method are not relevant to non local returns, therefore it will be discussed elsewhere.

Taking a look at the example, the loop consists of the following:
\begin{itemize}
	\item Local variable \texttt{x} is defined and assigned a value \texttt{0}.
	\item A block \texttt{[ x < 5 ]]} is created. The home context of this block is the context of \texttt{run} method. The block is therefore
		able to access the local variable of the method (variable \texttt{x} in this example).
	\item Before the actual message send, the argument is created. This results in another block being created with the same home context. Again, the block
		has access to the \texttt{x} variable each time it is evaluated.
	\item The message \texttt{whileTrue:} is sent to the first block, with the second one as an argument.
\end{itemize}

For reference, the implementation of relevant boolean methods used in the example are provided on figure \ref{fig:bool_ifFalse}.
\begin{figure}[h!]
	\begin{lstlisting}[language=Smalltalk]
		True = (
			ifFalse: aBlock = ( ^nil )
		)

		False = (
			ifFalse: aBlock = ( ^aBlock value )
		)
	\end{lstlisting}
	\caption{Implementation of relevant boolean methods.}
	\label{fig:bool_ifFalse}
\end{figure}

The execution then continues in the corresponding method:
\begin{itemize}
	\item A block \texttt{[ x < 5 ]} (\texttt{self}) is evaluated, returning the value \texttt{true}.
	\item The instance of \texttt{true} is sent a message \texttt{ifFalse:}. This returns the \texttt{nil} value.
	\item Execution continues by evaluating the argument block. This prints out the current value of \texttt{x} and
		increments its value by one. Note that even though the block is evaluated from the context of method
		\texttt{whileTrue:}, it is actually evaluated in its home context and still has access to the locals of 
		the home context. The closure captures the variable upon creation, not upon evaluation.
	\item The \texttt{restart} message is then sent to the first block, starting the execution of the method again.
\end{itemize}

This gets executed until the variable \texttt{x} holds a value 5. By then, the \texttt{self value} expression returns
\texttt{false}, therefore \texttt{ifFalse:} is sent to a different object. The argument is the block type, its home context
is the \texttt{whileTrue:} method context.

State of the execution environment upon this \texttt{ifFalse:} message send is depicted on figure .
\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth]{media/nlreturn_ex1.png}
	\caption{Created blocks and their home contexts.}
	\label{fig:nlreturn_ctx_1}
\end{figure}

The argument of the method \texttt{ifFalse:} contains a return statement. This is the non local return. When the block is
evaluated, the execution \textit{jumps out of the block's home context}. This means the execution ends up in the \texttt{run}
method, returning the value \texttt{nil}.

The contexts can be represented by stack frames. When performing local return from a current context, the execution returns to the
point that created it -- that means one frame is removed. In non local return, the execution can jump any numbers of contexts -- the
home context does not even have to exist anymore.

The concept of non local returns can get confusing when dealing with blocks assigned to variable, mainly instance variables.
The context in which the block is created and evaluated can be far apart. Consider the example at figure \ref{fig:nlreturn_2}, where two blocks are
assigned as instance variables -- one with a non local return, one without it.

\begin{figure}
	\centering
	\begin{lstlisting}[language=Smalltalk]
		NLReturn2 = (
			| lBlock nlBlock |

			run = (
				lBlock := [ 'Local return block' printLn ].
				nlBlock := [ ^'Non local return block' printLn ].
				1 to: 10 do: [ :index |
					index = 3
						ifTrue: [ nlBlock value ]
						ifFalse: [ lBlock value ]
				].
				'Run method is exiting' printLn
			)
		)
	\end{lstlisting}
	\caption{Second example code for non local returns.}
	\label{fig:nlreturn_2}
\end{figure}

The code assigns the instance variables block objects. Then blocks are evaluated in the loop, depending on the value
of the index of the iteration. If the index is equal to three, block with non local return is evaluated. Then the program
prints out exiting message. The output of the program is on figure \ref{fig:nlreturn_2_output}.

\begin{figure}[h!]
	\centering
	\begin{verbatim}
		Local return block
		Local return block
		Non local return block
	\end{verbatim}
	\caption{Output of the example code from figure \ref{fig:nlreturn_2}}
	\label{fig:nlreturn_2_output}
\end{figure}

As is evident from the program output, the excution stops after the third step of the iteration. The expression
following the iteration block is also not executed. When taking a look at the block contexts, it is clear why it is.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth]{media/nlreturn_ex2.png}
	\caption{State of execution before return for example on figure \ref{fig:nlreturn_2}.}
	\label{fig:nlreturn_2_ctx}
\end{figure}

There are multiple methods being called before the block is executed. With block in variable \texttt{lBlock}, the
block's home context plays little role -- after the block is executed, simple return is performed (from the method
\texttt{value}). With \texttt{nlBlock}, non local return is performed after evaluation -- meaning the execution jumps
out of the home context of the block -- which means the end execution of the program.

As stated earlier, the non local returns offer a great way to write more compact and readable code. There are some
pitfalls to be aware of. The nature of the non local returns means that it is not always obvious where the execution
ends up.

The last example serves to demonstrate how a created block can attempt to exit a context that no longer exists.

\begin{figure}[h!]
	\centering
	\begin{lstlisting}[language=Smalltalk]
		NLReturn3 = (
			| block1 block2 |
			run = (
				self createBlocks.
				block1 value.
				block2 value
			)

			createBlocks = (
				block1 := [ 'Local return' printLn ].
				block2 := [ ^'Non local return' printLn ]
			)
		)
	\end{lstlisting}
	\caption{Third example demonstrating non local returns.}
	\label{fig:nlreturn_3}
\end{figure}

Execution of this program will result in a runtime error. Both of the blocks are created in the context belonging to the method
\texttt{createBlocks}. While it may seem, that at least \texttt{block1} could be executed as the evaluation of that block
returns to the main method. However, none of the blocks can be evaluated in this case and the reason becomes clear with a 
slight modification to the \texttt{createBlocks} method, as seen on figure \ref{fig:nlreturn_3_2}.

\begin{figure}[h!]
	\centering
	\begin{lstlisting}[language=Smalltalk]
		createBlocks = (
			| mssg |
			mssg := 'Block evaluation'.
			block1 := [ mssg printLn ].
			block2 := [ ^mssg printLn ]
		)
	\end{lstlisting}
	\caption{Modification of the method from example \ref{fig:nlreturn_3}.}
	\label{fig:nlreturn_3_2}
\end{figure}

This modification to the method is completely valid -- both block are created within the method's context and thus
can access its local variables. However, after the return from this method, its context is discarded. By the time
blocks are evaluated, variable \texttt{mssg} does not exist.

\section{Expressions}
According to \cite{smalltalk-essentials}, \textit{an expression is a segment of code in a body of executable code
that can be evaluated to yield a value as a result of its execution.} Expressions can contain another expressions.

\begin{figure}[h!]
	\begin{verbatim}
	expression: assignation | evaluation;
	assignation: assignments evaluation;
	assignments: assignment+;
	assignment: variable ASSIGN;
	evaluation: primary messages?;
	primary: variable | nestedTerm | nestedBlock | literal;
	messages:
		  unaryMessage+ binaryMessage* keywordMessage?
		| binaryMessage+ keywordMessage?
		| keywordMessage;
	\end{verbatim}
	\caption{ANTLR grammar snippet for expressions.}
	\label{fig:grammar_exp}
\end{figure}

Syntactically, an expression can consist of \cite{smalltalk-essentials}:
\begin{itemize}
	\item literal,
	\item variable/constant reference,
	\item message send,
	\item nested expression.
\end{itemize}

\section{Control structures}
In Smalltalk, there are no built-in control structures, unlike for example C++ or Java. SOM follows this principle
from Smalltalk, therefore there are no grammatical rules for branching or loops.

The way controlling the flow of program works in SOM is, again, by sending messages. One big advantage of this 
approach is that the programmer can define their own control structures, simply by implementing classes and
methods as needed.

To make working with SOM easier and faster, my implementation provides multiple message implementations, 
corresponding to the most used control structures in other programming languages. Syntax of these messages
corresponds to other Smalltalk dialects.

\subsection{Conditional branching}
There are 3 messages that function as an if control structure. Selectors for these messages are \texttt{ifTrue:},
\texttt{ifFalse:}, \texttt{ifTrue:ifFalse:}. As apparent, they are keyword messages, the receiver is an instance of
a Boolean class. All of these messages take blocks as arguments, then evaluating or not evaluating them based on
the Boolean value. Figure \ref{lst-if-control} shows a simple example of usage.

\begin{figure}[h!]
	\begin{lstlisting}[language=Smalltalk]
		"Subtracts b from a only if a is greater then b"
		a > b ifTrue: [ a - b ].
		a <= b ifFalse: [ a - b ].
		"Subtracts the smaller number from the bigger one"
		a < b
			ifTrue: [ b - a ]
			ifFalse: [ a - b ]
	\end{lstlisting}
	\caption{Example of messages functioning as \textit{if-}control structures.}
	\label{lst-if-control}
\end{figure}

\subsection{For loops}
The simplest example of a for loop is iterating over a range of integers. There are 2 messages, \texttt{to:do:} and  \texttt{to:by:do:}.
The receiver of the message is an integer. The receiver of the message is the lower bound of the iteration, the argument for \texttt{to:}
keyword is the upper bound, \texttt{by:} specifies a step of iteration, \texttt{do:} takes a block that is evaluated (note that the block
has to have exactly one parameter, so it is possible to capture the value of index in every step).

\begin{figure}[h!]
	\begin{lstlisting}[language=Smalltalk]
		"Prints all numbers from 1 to 10"
		1 to: 10 do: [ :index | index asString printLn ].
		"Prints all the even numbers between 1 and 100"
		0 to: 100 by: 2 do: [ :index | index asString printLn ]
	\end{lstlisting}
	\caption{Example of simple for loops.}
	\label{lst-for-index}
\end{figure}

This way of looping is also usable when iterating over arrays (or any indexable collection). As seen on figure \ref{lst-for-array}, this method is not
very concise, therefore a message \texttt{do:} is implemented. Array class implements a method corresponding to this message, iterating
over every element of the array. It takes a block as an argument. The block has to have one parameter -- that is the element of the array
of the given step of the iteration.

\begin{figure}[h!]
	\begin{lstlisting}[language=Smalltalk]
		| array |
		array := #(1 2 3).
		"Printing the elements by iterating over index"
		1 to: array size do: [ :index |
			(array at: index) asString printLn ].
		"Printing the elements by iterating over array"
		array do: [ :element | element asString printLn ]
	\end{lstlisting}
	\caption{Examples of different ways of iterating over an array.}
	\label{lst-for-array}
\end{figure}

\subsection{While loops}
While loops are implemented as a unary message sent to a block that returns a boolean value. There are actually
two messages, \texttt{whileTrue} and \texttt{whileFalse}. The first one repeats the evaluation of a receiver (a block)
as long as it returns \texttt{true}. The second one, as the name suggests, does the same thing if the block returns
\texttt{false} value. Example in figure \ref{lst-while} shows printing numbers from 0 to 10 using \texttt{whileTrue}
message.

\begin{figure}[h!]
	\begin{lstlisting}[language=Smalltalk]
		| index |
		index := 0.
		[ index asString printLn.
		index := index + 1.
		index < 10
		] whileTrue
	\end{lstlisting}
	\caption{Example of while loops.}
	\label{lst-while}
\end{figure}

\subsection{Class hierarchy}
SOM supports single inheritance and it is a vital aspect of the language. As a purely object-oriented programming language,
it takes full advantage of polymorphism.

Single inheritance permits only one superclass per class. The superclass can be explicitly defined. If it is not defined,
every class is a subclass of special Object class. This therefore means that every object is an instance of the Object class
or its subclass.

Tied with inheritance is a principle of late binding. The method to invoke is decided during runtime. The method lookup is simple
-- it follows the chain of inheritance, from the subclass to superclass (always ending at Object class). 

\section{Abstract syntax tree}

\section{Bytecode}
The next step after constructing the AST is to compile it into a bytecode. The bytecode is saved in a binary file that can be
interpreted. The structure of bytecode files and semantics and syntax of operation codes is described in the following sections.

\subsection{Program structure}
SOM program has a very simple structure consisting of:
\begin{enumerate}
	\item \textbf{The constant pool:} This is a list of all the entities of the program. The choice of the word \textit{entity}
		over \textit{object} is intentional to avoid confusion with what objects are in OOP languages. Each entity can be accessed
		by its index.
	\item \textbf{Entry point: } An index to a Method that is executed on program start. There can only be one entry point to a
		program. It is a unary method with selector \texttt{run}. It can be a member of any class of the program.  
\end{enumerate}

\subsection{Program entities}
All entities in the constant pool are one of these types:
\begin{enumerate}
	\item \textbf{Nil entity} represents an undefined value.
	\item \textbf{Int entity} represents a 32 bit signed integer number. It is used for LIT instrucions.
	\item \textbf{Double entity} represents a double-precision floating point number.
	\item \textbf{String entity} represents a value of string of characters of arbitrary length. It is used for
		constants in the program as well as to store all the identifiers to classes, method selectors and variables.
	\item \textbf{Field entity} represents a variable in an object. It consists of one index to a string value that represents
		the name of the slot.
	\item \textbf{Method entity} represents a method of an object. It holds and index to a string representing the selector,
		number of arguments (arity of the corresponding message), number of local variables and an array of instructions.
	\item \textbf{Primitive entity} is a method that needs an implementation in the VM. These are used to handle constructs that
		cannot be expressed in the base language. 
	\item \textbf{Block entity} is a block of code. It holds the number of arguments and an array of instructions (similar
		to a method).
	\item \textbf{Class entity} represents the structure of objects. It consists of an array of indices to all the fields
		of the object. Each one of these fields point either to a Field entity or a Method entity.
\end{enumerate}

\subsection{Instructions}
\begin{itemize}
	\item \texttt{LIT i} retrieves a constant value from the constant pool at the index \texttt{i} and pushes it
		on the stack. The item can be either integer, double or string value.
	\item \texttt{GET SLOT i} pops a value from the operand stack, assuming it is an object. Then it retrieves a value
		with index \texttt{i} from the constatns pool, assuming it is a string. It then retrieves the value
		stored in the slot with the name specified by the string and pushes it onto the stack.
	\item \texttt{SET SLOT i} pops a value from the stack. This value is then assigned to an instance variable with identifier
		at index \texttt{i} in the constants pool.
	\item \texttt{SEND i n} sends a message to an object, which in most cases results in calling a method. A new frame
		is created on the execution stack, arguments are pushed and the execution jumps to the first instruction of the
		method.
	\item \texttt{GET LOCAL i} retrieves a local variable with an index \texttt{i} and pushes it to the top of the stack.
	\item \texttt{SET LOCAL i} pops a value \texttt{x} from the top of the stack and then assignes the \texttt{x} into
		a local variable with the index \texttt{i}.
	\item \texttt{GET SELF} retrieves the callee of executed method. The object is pushed to the top of the stack.
	\item \texttt{GET ARG i} retrieves the i--th argument of the current message from the stack and pushes it on top.
	\item \texttt{BLOCK i} creates a code block object. The argument \texttt{i} points to a block value in the constant pool.
		The block object is instantiated on the heap and pushed to the top of the stack.
	\item \texttt{RET} is used to return from a method call. The value from the top of the stack is returned. The address
		to return to is retrieved from the current frame, then the frame is popped and execution jumps to an instruction
		after the \texttt{CALL} that invoked the method.
	\item \texttt{RETNL i} - non local return. The value at the top of the current frame is used as the return value. Argument
		\texttt{i} specifies the number of frames to be popped, then the return value is pushed to the top of the current frame.
\end{itemize}

\section{Garbage collection}
The process of \textit{garbage collection} performed by \textit{garbage collector (GC)} is the process of allocating and freeing
memory during application runtime. The main advantage of this mechanics is to prevent \textit{memory leaks} -- parts of a program
that allocate memory without freeing it when it is not needed \cite{memleaks-raygun}. Most modern high-level programming languages
implement some form of garbage collection.

There are multiple possible algorithms that solve this problem. I have decided to implement a mark and sweep algorithm, due to
its simplicity. The expectation is that this algorithm will not be particularly fast, though it leaves a lot of room for possible
improvements and it can be used as a demonstration of performance effects of a garbage collector.

\subsection{Mark and sweep}
According to \cite{gc-ms}, the algorithm consists of two main phases:
\begin{itemize}
	\item Mark phase -- discovery of all the reachable objects.
	\item Sweep phase -- clearing the heap of all unreachable objects.
\end{itemize}

Every object allocated on the heap holds a mark bit. This represents the reachability of the object -- 0 (false) for
unreachable, 1 (true) for reachable. Upon object creation, the mark bit is set to zero. In the sweep phase a simple
graph traversal algorithm can be used (such as DFS -- Depth First Search) to mark all the reachable objects. Every
objects can be considered a node and variables serve as neighbour lists. Root nodes would be local variable and fields
that are directly accessible.

In the sweep phase, the whole heap can be traversed linearly and objects with mark bit set to zero are deleted. As the \cite{gc-ms}
states, main advantages of this algorithm are:
\begin{itemize}
	\item algorithm handles cyclic references and therefore cannot end up in an infinite loop,
	\item no additional overheard during the execution of the algorithm (such as extra data structures etc.).
\end{itemize}

On the other hand, the simplicity of the algorithm means there are some disadvantages:
\begin{itemize}
	\item normal program execution is suspended during the garbage collection process,
	\item the algorithm does not address memory fragmentation.
\end{itemize}

The problem of memory fragmentation means that after several runs of the algorithm, the reachable objects will be separated
by chunks of free memory. This can be solved by shuffling the objects, though at a cost of further performance degradation.

To demonstrate the execution of the algorithm, consider the following object hierarchy allocated during a program execution.
Each node represents an object allocated on the heap, with marked bit set to false. Arrows represent variable references
from on object to another. In reality, there will be multiple root objects -- therefore the algorithm can run for every
root object.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{media/gc_ms_step1.png}
	\caption{Illustration of the object hierarchy before GC algorithm run.}
	\label{fig:gc_step1}
\end{figure}

The heap is then traversed from the root object (figure \ref{fig:gc_step2}). Each colour represents one step of the traversal. This example represents
breadth first search.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{media/gc_ms_step2color.png}
	\caption{Traversal of the heap objects.}
	\label{fig:gc_step2}
\end{figure}

After the run of the mark phase, all the objects reachable from the root objects (or multiple root objects after a run for each one) are marked.
One linear traversal over objects can then remove all of the unmarked ones (figure \ref{fig:gc_step3}).

\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth]{media/gc_ms_step3.png}
	\caption{State of the heap after the GC run.}
	\label{fig:gc_step3}
\end{figure}

\chapter{Realisation}

\section{Program overview}
The program I have implemented provides a way to compile SOM source code and execute it.

\begin{figure}[h!]
	\centering
	\begin{verbatim}
		<som_executable> [OPTION] [SOURCE]
	\end{verbatim}
	\caption{Interface of the program.}
	\label{fig:prog_interface}
\end{figure}

The interface of the application is simple and consists of two user provided arguments.

The argument \texttt{OPTION} can have two values and alters the mode the app will function in:
\begin{itemize}
	\item \texttt{-c} is compile mode. The argument \texttt{SOURCE} is a folder containing the source code of the program.
		This folder is searched for SOM source files -- those are recognized by their file extension, which should be \texttt{.som}.
		The folder is searched non recursively. Every SOM source file is compiled and one binary file containing bytecode is created.
		The name of the file is the same as the provided folder name.
	\item \texttt{-r} loads and runs a compiled bytecode. The \texttt{SOURCE} argument is a file name of the compiled bytecode.
\end{itemize}

\section{Abstract Syntax Tree}
After the parsing is complete, Abstract Syntax Tree (AST) is constructed. AST is, by definition, stripped of many syntactic detail.
It mainly represents the structural and content-related aspects of the code.

The conceptual design of the AST is depicted on figure \ref{fig:ast_class_concept}.

\begin{figure}[hp!]
	\centering
	\includegraphics[width=\textwidth, height=\textheight]{media/ast/ast_concept.png}
	\caption{Conceptual class diagram for SOM abstract syntax tree.}
	\label{fig:ast_class_concept}
\end{figure}

\subsection{AST Nodes}
\textbf{Class} node represents a class in the program, while the program itself is basically an array of different classes. A class
holds its name, its member fields (member variables in C++ terminology), instance-side methods (member functions), class-side fields
(static member variables) and class-side methods (static member functions).

\textbf{Method} node represents a method -- instance or class side. It consists of a pattern, local variable definitions and a block
to be executed.

\textbf{Pattern} represents a message corresponding to the method. There are 3 types of messages in SOM, therefore there are 3 distinct
types of patterns. The simplest one is \textbf{unary pattern} -- consisting of only one identifier as there are no arguments. \textbf{Binary pattern}
is treated as a separate pattern. It consists of identifier and exactly one argument. There are special requirments for binary pattern identifier
-- there is a special set of characters permitted that can form a binary pattern. \textbf{Keyword pattern} then consists of one or more keywords and
same number of arguments, each correpsonding to one keyword. Concatenation of keywords form a selector of the method. \textbf{Keywords} holds the string
value of the keyword, always ending in colon (:).

\textbf{Variable} node represents instance/class side variables, arguments to messages or blocks. It holds the identifier of the variable as a string value.

\textbf{Block} represents a block of executable code with its own scope. The simplest block consists of local variable definitions and an array of
expressions to be evaluated. While this is enough to represent a method block, other uses may require more information, therefore there is another
similar node discussed later.

\subsubsection{Expressions}
\textbf{Expression} is an abstract term in the context of the AST - there are two types. The common thing is they can be evaluated -- therefore forming
the actual executable code of the program. 

\textbf{Evaluation} is the first form of expression - it represents a message sends to an object, thus returning a single value when evaluated. This node
consists of messages (optional) and a \textit{primary}.

\textbf{Primary} is another abstract concept. In its core, a primary represents an object, though there are multiple ways to reference an object in SOM.
There are four AST nodes that can be classified as a primary:
\begin{itemize}
	\item \textbf{Literal} -- a constant basic value (of integer, floating point, string or array type). Each of these have their dedicated literal node
		holding the value as seen on figure TODO.
	\item \textbf{Variable} is self explanatory -- a reference to an object accessed via the identifier.
	\item \textbf{Nested term} is an expression that needs to be evaluated to retrieve the reference to an object. Syntactically, the nested terms
		are enclosed in parentheses.
	\item \textbf{Nested block} is a block of expressions returning the reference to an object. It is enclosed in square brackets in the syntax.
		Nested blocks consist of the same elements as block discussed with methods with addition of a block pattern -- nested block can have their arguments. %TODO: reference the section where blocks are discussed
\end{itemize}

The second part of the evaluation node is the message sends to the primary. There are three types corresponding to three types of messages in SOM.
\texttt{UnaryMessage} node is self explanatory -- there are no arguments, only the message selector. \texttt{BinaryMessage} holds its selector too
with addition of the argument. The argument of the binary message send can be a primary, along with unary message sends (because unary message sends take
precedence). \texttt{KeywordMessage} is made up of the keywords (forming the selector) and something called \textit{formulas}. Formulas are binary (and also unary) message
sends, that take precedence over keyword messages.

\textbf{Assignation} is the second form of an expression. The name suggests this node represents assigning a value into a variable. Therefore the node consists
of the \texttt{Variable} node to assign to and an \texttt{Evaluation} node returning the value to assign.

Expression with an explicit return statement is encapsulated in an \texttt{Result} node. The information about explicit return being used is needed
to handle non local returns.

Consider the following expressions:
\begin{figure}[h!]
	\centering
	\begin{lstlisting}[language=Smalltalk]
		"Expression 1"
		receiver1 foo: x asString bar: (x + y toInteger) 
	\end{lstlisting}
	\caption{Example for AST construction.}
	\label{fig:ast_constr_ex}
\end{figure}

Expression 1 is a keyword message send to a variable \texttt{receiver1}, with arguments as sub-expressions. The AST produced for this expression is
on figure .

\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{media/exp_ast_1.png}
	\caption{First expression from example \ref{fig:ast_constr_ex} as AST.}
	\label{fig:ast_const_ex_1}
\end{figure}

\subsection{AST construction}
The AST is constructed by visiting over the ANTLR--generated parse tree. The visitor is implemented in class \texttt{CParseTreeConverter}. This is a subclass
of \texttt{SOMParserBaseVisitor}, which is a base visitor implementation provided by ANTLR that perform depth--first traversal over the parse tree. Some member
functions in \texttt{CParseTreeConverter} are not overriden and make use of this default behaviour (which is just iterating over child nodes and visiting them).

\section{Bytecode}
After constructing the AST it is turned into a bytecode. The bytecode definitions are located in source files \texttt{Bytecode.h}/\texttt{Bytecode.cpp}. The actual
compilation is implemented as a depth--first traversal of the AST, therefore a visitor pattern is used. There is an abstract class \texttt{ASTVisitor} that defines
the interface of any AST visitor. This can be used to further implement visualisations of the AST or to add support for different bytecode instructions sets,
for example Java bytecode to add support for running inside a Java runtime.

\subsection{Values}
Every constant value in the code is saved as a \texttt{Value} struct. Each value contains the one byte tag and the actual value to hold. There are method implementations
to print every value into human readable format for better visualisation of the compiled bytecode. Additionally, every instruction struct is able to serialize itself -- 
write the data needed in binary format to a file.

\subsection{Instructions}
Similar to values, every instruction is represented by a struct holding the relevant information (such as operation codes and arguments). Every instruction is capable
of printing itself in human readable format and serialize itself to binary format, the same as all the values.

\section{Interpretation}
The process of interpreting the loaded bytecode is handled by class \texttt{CInterpret}. The class diagram of the interpretation environment is
in the figure \ref{fig:interpret_classDiagram}. The diagram serves as a reference point, all the parts are described in further detail in the
following sections.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{media/interpret_class.png}
	\caption{Conceptual class diagram for interpretation environment.}
	\label{fig:interpret_classDiagram}
\end{figure}

\subsection{Program counter}
The class \texttt{CProgramCounter} is an implementation for a program counter for the VM. During initialization of this object, the entry point of the program is loaded.
The program counter also saves the "end" address. The addresses are implemented as iterators to a vector of instructions -- that is possible simply because all of the
executable code will be contained within a method, and all the method are loaded into a vector of instructions. The entry point of the program is therefore the first
instruction of the \texttt{run} method, while "end" address is the end iterator of the same vector. This means that the end address is not an executable instruction.

\subsection{Execution stack}
The execution stack is responsible for management of method calls (and nested block evaluations). It is implemented as a LIFO (last in, first out) structure.
For every method call or block evaluation, a new frame is created and pushed on the stack. A frame contains:
\begin{itemize}
	\item Arguments accessible by their index, assigned at compilation. For the sake of stack, the callee is also considered an argument and is always
		the last element of the arguments array.
	\item Array of local variables, accessible by their index assigned during compilation.
	\item Return address. The program counter is set to this address when a \texttt{RET} instruction is executed.
	\item The address of the beginning of the current context. This is used only to achieve iteration without the need of recursion.
	\item Local data for the method/block execution. This part is used for all the temporary object creation (e.g. literal values) and argument passing.
\end{itemize}

Sending a message or evaluating a block therefore can be split into multiple steps:
\begin{itemize}
	\item The receiver of the message is pushed to the stack.
	\item The arguments are then pushed to the stack, in the order from left to right.
	\item When the \texttt{SEND} instruction is executed, new stack frame is created. The return address is initialized to the address of the instruction
		following the \texttt{SEND} instruction. Array of arguments is initialized with the values from the top of the stack, number of arguments is provided
		as an argument of the instruction.
	\item The new frame is pushed to the stack. The receiver is then accessed, added to the end of the argument array and given the responsibility to invoke
		the method corresponding to the sent message.
\end{itemize}

When returning, the top of the stack contains the return value of the method or block. The frame is popped from the stack, program counter is set to the return
address and the top value is pushed to the new top of the stack.

\subsection{Objects}
Every object created during runtime (implicitly or explicitely) is represented by the \texttt{VMObject} class. Every value is represented by an instance of this
class or its subclass. Every object holds a pointer to its class and a map of the instance values -- the identifier as a key, object pointers as a value. Upon creation,
instance field values are initialize to the \texttt{nil} value.

Every class is represented by a \texttt{VMClass} instance, which is a subclass of \texttt{VMObject}. This allows us to manipulate every class as an object. There
is only one class instance per class definition during runtime and instantiating new class object is not possible. Before the execution of the code, the bytecode
is traversed and for every \texttt{CLASS} value, a singleton object is created and initialized. These objects are accessible globally by the identifier -- the class name.

Every class holds all the information needed to create and manipulate its instance. This includes the method dispatch.

\subsubsection{Object creation}
One of the main responsibilities of the class object is to handle dynamic creation of its instances. This is done via a \texttt{new} message send.
Upon the \texttt{new} message send:
\begin{itemize}
	\item new \texttt{VMObject} is created on the heap and its class is set,
	\item instance fields of the new object are initialized,
	\item pointer to the new object is returned.
\end{itemize}

\subsection{Messages}
In SOM, almost everything is handled via message sends. Message sends invoke a method, implemented either directly in SOM, or as a primitive.
The process of invoking a method on an object depends on what kind of message is sent. Additionally, a small number of special cases needs to
be handled for code blocks, to allow for iteration.

When a \texttt{SEND} instruction is encountered, the receiver of the message is retrieved from the stack. As the receiver is pushed to the stack
first, before the argument, it needs to be retrieved using the message arity. To achieve the late binding, the selector (a string value)
is then retrieved from the constants pool. 

Reference to the class of the object than handles the method dispatch. Slight differences in method dispatch between primitives and native
methods are discussed in further detail in section TODO.

Every method invokation results in a new frame being created on the execution stack. Because the execution stack is implemented as a
stack of separate objects representing the frames (and not a continuous array), every new frame needs to be initialized. This handles
the argument passing, as well as scoping of local variables when sending messages to code blocks.

When the new frame is created, multiple actions take place:
\begin{itemize}
	\item Return address on the frame is set to the instruction following the \texttt{SEND} instruction. As every block of code must end
		with return (simple or non -- local), the existence of the address is guaranteed.
	\item The array of arguments is initialized. Arguments had been pushed to the stack in the order of corresponding keywords (therefore
		left to right). As a result, the arguments are reversed in the actual array -- member functions access them from the back. The
		last argument is set to the reciever -- that is the object accessed by \texttt{self} keyword (comparable to \texttt{this} pointer in
		C++).
	\item Array of local variable is initialized. This step is skipped for every object outside of code blocks -- instances of \texttt{Block}
		class. This is due to the scoping rules -- code blocks can access the local variables of the method, in which they are evaluated.
\end{itemize}

After the new stack frame is created, the execution of the method can take place. For primitive values, the corresponding member function
is called directly in the VM. For native methods, program counter is set to the address of the method and interpreting loop continues.

Method execution should always end with the return value at the top of the stack -- for primitives and native methods. Every method
should also end with the \texttt{RET} instruction. When this instruction is executed, the top value of the current stack is taken.
The top frame of the stack is removed, program counter is set to its return address and the top value is pushed to the top of the
underlying frame. Interpreting loop can then continue.

\subsection{Core library}
SOM programming language is very light on features. In order for it to be usable, there needs to be an implementation of some fundamental principles provided.
For example, the language itself does not provide a way to manipulate numbers, character strings, standard input and output or control structures. All of these
can be implemented in the VM itself while preserving the consistency of rules of the language.

In order to achieve that, a keyword \texttt{primitive} is defined. This keyword is used for methods that require an implementation in the VM runtime. From the outside,
caling a primitive method is no different than calling a method implemented directly in SOM.

While the user is able to implement their own primitives, a lot of them are already provided in the core library. This library is a set of classes loaded every time
a SOM code is interpreted. This library provides implementations for:
\begin{itemize}
	\item strings,
	\item numbers -- integers and doubles,
	\item boolean values with messages that provided control flow features,
	\item code blocks,
	\item arrays.
\end{itemize}

\subsection{Primitives}
\label{subsection:primitives}
Every class that marks a method primitive has to provide its implementation in the VM. This is done by creating a new subclass of \texttt{VMClass}. This subclass
then has to implement the primitive methods (in the form of \texttt{void} member functions that take \texttt{CInterpret*} as an argument). Resolving of method
selector (which is a simple string) and the function to invoke is then done via member function \texttt{dispatchPrimitive}.

\subsubsection{Strings}
Every literal string value is represented by an instance of \texttt{String} class during runtime. The corresponding class implementing the primitives is
\texttt{VMClass}. In SOM, every string object is immutable, therefore every string manipulation results in creating a new string object.

This approach can however lead to inefficiencies when constructing strings. To combat this, a class handling dynamic string creation could
be implemented, similar to streams.

When looking at String implementation, there is a big difference to how they are implemented in SOM and Smalltalk. When a string object
is created in Smalltalk, it is handled as an object with indexed fields, each containing a character. My implementaion of SOM does not
conform to this, as strings are simply handled in the VM runtime. Possible extension of the language could be developed, allowing for
creation of objects with indexed fields.

This could be the applied to arrays, thus creating a unified ways to handle collections.

\subsection{Blocks}
As blocks are treated as any other objects in SOM, there needs to be a class implemented for them. Every block in the program is 
an instance of the \texttt{Block} class. Given the special nature of blocks (as discussed in section \ref{subsection:nlret}), they
require more implementation details compared to other classes.

\begin{figure}[h!]
	\centering
	\begin{lstlisting}[language=Smalltalk]
		Block = (
			value = primitive
			value: arg = primitive
			"More evaluation methods omitted"
			
			whileTrue: block = (
				self value ifFalse: [ ^nil ].
				block value.
				self restart
			)

			whileFalse: block = (
				[ self value not ] whileTrue: block
			)
		)
	\end{lstlisting}
\end{figure}

The actual implementation for blocks is pretty simple -- methods for evaluating and methods for iterating (simulating while loops known from
other programming languages).

Every block created is an object instance -- therefore it is implemented as an instance of \texttt{VMObject} in the VM. Every block object is
initialized with a special primitive value (struct \texttt{BlockContext}), holding information needed to evaluate the block. That is:
\begin{itemize}
	\item address of the first instruction of the block,
	\item a pointer to the home context of the block (pointer to the stack frame corresponding with the method that created the block).
\end{itemize}

\subsubsection{Evaluation}
What happens upon the evaluation of the block is as follows:
\begin{itemize}
	\item The message \texttt{value} (or any variant with arguments) is sent to a block object. This is dispatched using standard method
		dispatch. As a part of standard method dispatch, new stack frame is created and the execution of the primitive method starts.
	\item Upon the start of the execution of the method, the new stack frame is discarded and replaced by the block's home context. In
		standard situations, this will result in multiple pointers pointing to a single frame (as execution stack stores pointers to frames).
		The return address from the discarded frame is saved, as that is the return address in the case of local return.
	\item Program counter is set to the first instruction of the block.
	\item The local return address is set in a separate part of the context. It cannot overwrite the return address already in the context,
		as that is needed in case execution moves to the context of the executed block again.
	\item The interpret loop is called (creating a nested call inside of the main interpret loop). On one of the return instructions, 
		interpret jumps out of the nested interpret call. 
\end{itemize}

Every block ends with \texttt{RETNL i} instruction. The integer from an argument decides the behaviour of the return.
\begin{itemize}
	\item If \texttt{i = 1}, the return behaves as a local return. Interpretation jumps out of the nested interpret loop, than removes
		the top stack frame (as is standard for every return from a method). As a return address, the special value from the initially
		discarded stack frame is used.
	\item If \texttt{i > 1}, the return is a non local return. Stack frames are popped until the block's home context is at the top.
		The standard return from that context ensures the execution returns from the block's home context. The execution of the program
		ends if the home context is the bottom--most frame on the stack.
\end{itemize}

Consider the following example of a simple block evaluation on figure \ref{fig:block_eval_1}:
\begin{figure}[h!]
	\centering
	\begin{lstlisting}[language=Smalltalk]
		BlockEval = (
			run = ( [ 'Hello' printLn ] value )
		)
	\end{lstlisting}
	\caption{Example to demonstrate block evaluation process.}
	\label{fig:block_eval_1}
\end{figure}

The state of the interpret environment after the \texttt{value} message send (right before the first block instruction is evaluated) is depicted 
on figure \ref{fig:block_eval_1_diagram}.

\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{media/block_exec_1.png}
	\caption{State of execution environment for execution of example \ref{fig:block_eval_1}.}
	\label{fig:block_eval_1_diagram}
\end{figure}

There are few things to note. First, the execution stack contains one stack frame two times. This is to ensure that:
\begin{itemize}
	\item block can be evaluated in its home context without the need to copy values on initialization and again on return,
	\item standard mechanism for returning from methods can be used when performing local return from the block.
\end{itemize}

In this case, local return address and standard return address are the same, because the block is evaluated in its home context.
This does not always has to be the case. In the example, the local return address is used as the block does not perform non local
return.

\subsubsection{Argument handling}
Every block can require arbitrary number of arguments in order to be evaluated. Given that blocks are executed inside already existing
contexts (with possible existing arguments), this needs to be handled on two levels:
\begin{itemize}
	\item During compilation. The arguments are not resolved via their identifier, but they are assigned an index in their scope.
		The indices of the block cannot clash with already existing ones (arguments of the method creating the block).
	\item During interpretation. At the beginning of block evaluation, the values of arguments have to be initialized inside the home context.
		They then have to be removed as to not be accessible from the original method.
\end{itemize}

\subsubsection{Block restart}
In order to achieve a possibility of iteration without the need of recursive calls, \texttt{Block} class implements a special \texttt{restart} method.
The method is implemented as primitive and is used in core library. When writing programs in SOM, the programmer should use existing messages aimed at
providing iteration functionality, thus the use of this message outside of core library is not recommended.

The method simulates a recursive execution of a method, without the need of allocating and initializing new stack frames on each message send.
Implementation itself is pretty simple:
\begin{itemize}
	\item New stack frame is created as a part of standard message send mechanism. This stack frame is discarded.
	\item The program counter is set to the address of the initial instruction of curent context (stack frame).
	\item Interpret loop is then called to avoid context exiting mechanisms.
\end{itemize}

\setsecnumdepth{part}
\chapter{Conclusion}


\bibliographystyle{iso690}
\bibliography{mybibliographyfile}

\setsecnumdepth{all}
\appendix

\chapter{Acronyms}
% \printglossaries
\begin{description}
	\item[AST] Abstract syntax tree
	\item[GC] Garbage collector
	\item[SOM] Simple Object Machine 
	\item[VM] Virtual machine 
\end{description}


\chapter{Contents of enclosed CD}

%change appropriately

\begin{figure}
	\dirtree{%
		.1 readme.txt\DTcomment{the file with CD contents description}.
		.1 exe\DTcomment{the directory with executables}.
		.1 src\DTcomment{the directory of source codes}.
		.2 wbdcm\DTcomment{implementation sources}.
		.2 thesis\DTcomment{the directory of \LaTeX{} source codes of the thesis}.
		.1 text\DTcomment{the thesis text directory}.
		.2 thesis.pdf\DTcomment{the thesis text in PDF format}.
		.2 thesis.ps\DTcomment{the thesis text in PS format}.
	}
\end{figure}

\end{document}
