% arara: xelatex
% arara: xelatex
% arara: xelatex


\documentclass[thesis=M,english]{FITthesis}[2019/12/23]

%\usepackage[utf8]{inputenc} % LaTeX source encoded as UTF-8
% \usepackage[latin2]{inputenc} % LaTeX source encoded as ISO-8859-2
% \usepackage[cp1250]{inputenc} % LaTeX source encoded as Windows-1250

% \usepackage{subfig} %subfigures
% \usepackage{amsmath} %advanced maths
% \usepackage{amssymb} %additional math symbols

\usepackage{dirtree} %directory tree visualisation
\usepackage{url}
\input{smalltalkEnv.tex}

% % list of acronyms
% \usepackage[acronym,nonumberlist,toc,numberedsection=autolabel]{glossaries}
% \iflanguage{czech}{\renewcommand*{\acronymname}{Seznam pou{\v z}it{\' y}ch zkratek}}{}
% \makeglossaries

\department{Department of Theoretical Computer Science}
\title{SimpleObjectMachine implementation}
\authorGN{Rudolf} %author's given name/names
\authorFN{Rovňák} %author's surname
\author{Rudolf Rovňák} %author's name without academic degrees
\authorWithDegrees{Bc. Rudolf Rovňák} %author's name with academic degrees
\supervisor{Ing. Petr Máj}
\acknowledgements{THANKS (remove entirely in case you do not with to thank anyone)}
\abstractEN{Summarize the contents and contribution of your work in a few sentences in English language.}
\abstractCS{V n{\v e}kolika v{\v e}t{\' a}ch shr{\v n}te obsah a p{\v r}{\' i}nos t{\' e}to pr{\' a}ce v {\v c}esk{\' e}m jazyce.}
\placeForDeclarationOfAuthenticity{Prague}
\keywordsCS{Replace with comma-separated list of keywords in Czech.}
\keywordsEN{Replace with comma-separated list of keywords in English.}
\declarationOfAuthenticityOption{1} %select as appropriate, according to the desired license (integer 1-6)
% \website{http://site.example/thesis} %optional thesis URL


\begin{document}

% \newacronym{CVUT}{{\v C}VUT}{{\v C}esk{\' e} vysok{\' e} u{\v c}en{\' i} technick{\' e} v Praze}
% \newacronym{FIT}{FIT}{Fakulta informa{\v c}n{\' i}ch technologi{\' i}}

\setsecnumdepth{part}
\chapter{Introduction}



\setsecnumdepth{all}
\chapter{State-of-the-art}

\chapter{Analysis and design}
\section{SOM design and features}
\textit{Simple Object Machine} (SOM) is a minimal Smalltalk dialect used primarily for teaching construction of virtual machines. Key characteristics
according to official website (\cite{som-github}) are:
\begin{itemize}
	\item clarity of implementation over performance,
	\item common language features such as: objects, classes, closures, non-local returns
	\item interpreter optimizations, threading, garbage collectors are different
		across various implementations.
\end{itemize}

\subsection{Data types}


\subsection{Classes}
Classes are the cornerstone of SOM - in Smalltalk, everything is an object and each object has its class. Classes can contain fields and methods.
Only single inheritance is supported - given class can only extend one other class. Object methods are dispatched dynamically in SOM and there is
a keyword to explicitly call a superclass' method. 

SOM implements a non-local return from methods. This gives us the ability to exit the execution of a block (or a closure) to the place where the
original method calling the block returns.

\subsection{Class hierarchy}
As SOM is an object oriented language, everything is represented as an object. To enable more convenient work with classes and objects,
every class is a subclass of \texttt{Object}. This enables som universal interface to be used.

Protocol of an \texttt{Object} class is:
\begin{itemize}
	\item \texttt{class} - returns the class of an object,
	\item \texttt{=} - value equality comparison,
	\item \texttt{==} - reference equality comparison,
	\item \texttt{isNil} - check, if the object is \texttt{nil},
	\item \texttt{asString} - converts the object into a string,
	\item \texttt{value} - evaluate (interesting for blocks),
	\item \texttt{print, println} - prints the object,
	\item \texttt{error:} - error reporting,
	\item \texttt{subClassResponsibility} - can be used to indicate the method should be
		implemented in the subclass of a given class,
	\item \texttt{doesNotUnderstand:arguments:} - can be used for error handling when a method is not implemented.
\end{itemize}

\subsection{Syntax}
Following example summarizes the syntax of SOM programming language:
\begin{lstlisting}[language=Smalltalk]
MyClass = SuperClass (
	| field | "Instance side field"
	
	foo: arg = primitive "This method is implemented in the VM"

	examples = (
		| aMethodVariable |
		1234 "an integer".
		3.14 "a double".
		'a string'.
		"a comment".
		#aSymbol.
		aVariable := aVariable := 3 + 4.
		field select: [:e | e == #bar] "A message  send with a closure"
		^ aVariable "Return"
	)
	----
	| classField | "Class side field"
)
\end{lstlisting}

Some notable keywords or tokens are:
\begin{itemize}
	\item \texttt{self} is used to reference the object the method is from, comparable to C++/Java \texttt{this},
	\item \texttt{super} is used to reference the superclass of a class,
	\item \texttt{:=} is used to assign value into a variable/field,
	\item \texttt{\^} is used for return,
	\item quotes are used to delimit a comment.
\end{itemize}

\section{Interpretation}
Once the source code is parsed, the next step is executing it -- this step is called \textit{interpretation}. Interpretation is
As per \cite{wolczko-02-ast-interpret}, an interpreter for a language L can be defined as a mechanism for the direct execution of all programs
from L. It executes each element of the program without reference to other elements.

It is however very rare that any language is interpreted directly. In most cases of non-trivial languages, the interpretation process
is preceeded by parsing or compiling into some form of \textit{intermediate representation}. According to \cite{wolczko-02-ast-interpret},
this process removes lexical noise (comments, formating), elements can be abstracted/combined (into keywords, operations etc.) and reordered
into execution order (for example operators in an algebraic expression).

The choice of intermediate representation is therefore vital. It can determine a lot of aspects of interpretation - from the way of distributing
the interpreted program to time and space complexity of the interpreter.

\subsection{AST interpretation}
\textit{Abstract syntax tree (AST) is a tree representation of the source code of a computer program that conveys the structure of the source code.
Each node in the tree represents a construct occuring in the source code }\cite{deepsource-ast}.

As the name suggests, AST represents the source code in the form of a tree. During the transformation from the source code to AST, some information
is ommitted. Information that is vital for AST's according to \cite{deepsource-ast} is:
\begin{itemize}
	\item variables -- their types, location of their definition/declaration,
	\item order of commands/operations,
	\item components of operators and their position (for example left and right operands for a binary operator),
	\item identifiers and corresponding values.
\end{itemize}

\subsection{Bytecode interpretation}
Using a form of bytecode. Effective, requires:
\begin{itemize}
	\item designing the bytecode (instructions, bytecode file formats),
	\item AST to bytecode translation (AST -> bytecode instructions),
	\item actual bytecode interpretation.
\end{itemize}
Bytecode interpretation permits easier optimization.

\section{Optimization}
\begin{itemize}
	\item dead code elimination,
	\item constant propagation,
	\item others\ldots
\end{itemize}

\section{Virtual Machine}
Decide on memory hierarchy, garbage collection\ldots

\subsection{Garbage collection}
The process of \textit{garbage collection} performed by \textit{garbage collector (GC)} is the process of allocating and freeing
memory during application runtime. The main advantage of this mechanics is to prevent \textit{memory leaks} -- parts of a program
that allocate memory without freeing it when it is not needed \cite{memleaks-raygun}. Most modern high-level programming languages
implement some form of garbage collection.



\chapter{Realisation}

\setsecnumdepth{part}
\chapter{Conclusion}


\bibliographystyle{iso690}
\bibliography{mybibliographyfile}

\setsecnumdepth{all}
\appendix

\chapter{Acronyms}
% \printglossaries
\begin{description}
	\item[AST] Abstract syntax tree
	\item[GC] Garbage collector
	\item[SOM] Simple Object Machine 
	\item[VM] Virtual machine 
\end{description}


\chapter{Contents of enclosed CD}

%change appropriately

\begin{figure}
	\dirtree{%
		.1 readme.txt\DTcomment{the file with CD contents description}.
		.1 exe\DTcomment{the directory with executables}.
		.1 src\DTcomment{the directory of source codes}.
		.2 wbdcm\DTcomment{implementation sources}.
		.2 thesis\DTcomment{the directory of \LaTeX{} source codes of the thesis}.
		.1 text\DTcomment{the thesis text directory}.
		.2 thesis.pdf\DTcomment{the thesis text in PDF format}.
		.2 thesis.ps\DTcomment{the thesis text in PS format}.
	}
\end{figure}

\end{document}
