% arara: xelatex
% arara: xelatex
% arara: xelatex


\documentclass[thesis=M,english]{FITthesis}[2019/12/23]

%\usepackage[utf8]{inputenc} % LaTeX source encoded as UTF-8
% \usepackage[latin2]{inputenc} % LaTeX source encoded as ISO-8859-2
% \usepackage[cp1250]{inputenc} % LaTeX source encoded as Windows-1250

% \usepackage{subfig} %subfigures
% \usepackage{amsmath} %advanced maths
% \usepackage{amssymb} %additional math symbols

\usepackage{dirtree} %directory tree visualisation
\usepackage{hyperref}
\usepackage{url}
% \usepackage{svg}
\usepackage{lscape}
\usepackage{rotating}
\input{smalltalkEnv.tex}

% % list of acronyms
% \usepackage[acronym,nonumberlist,toc,numberedsection=autolabel]{glossaries}
% \iflanguage{czech}{\renewcommand*{\acronymname}{Seznam pou{\v z}it{\' y}ch zkratek}}{}
% \makeglossaries

\department{Department of Theoretical Computer Science}
\title{SimpleObjectMachine implementation}
\authorGN{Rudolf} %author's given name/names
\authorFN{Rovňák} %author's surname
\author{Rudolf Rovňák} %author's name without academic degrees
\authorWithDegrees{Bc. Rudolf Rovňák} %author's name with academic degrees
\supervisor{Ing. Petr Máj}
\acknowledgements{THANKS (remove entirely in case you do not with to thank anyone)}
\abstractEN{Summarize the contents and contribution of your work in a few sentences in English language.}
\abstractCS{V n{\v e}kolika v{\v e}t{\' a}ch shr{\v n}te obsah a p{\v r}{\' i}nos t{\' e}to pr{\' a}ce v {\v c}esk{\' e}m jazyce.}
\placeForDeclarationOfAuthenticity{Prague}
\keywordsCS{Replace with comma-separated list of keywords in Czech.}
\keywordsEN{Replace with comma-separated list of keywords in English.}
\declarationOfAuthenticityOption{1} %select as appropriate, according to the desired license (integer 1-6)
% \website{http://site.example/thesis} %optional thesis URL


\begin{document}

% \newacronym{CVUT}{{\v C}VUT}{{\v C}esk{\' e} vysok{\' e} u{\v c}en{\' i} technick{\' e} v Praze}
% \newacronym{FIT}{FIT}{Fakulta informa{\v c}n{\' i}ch technologi{\' i}}

% \setsecnumdepth{part}
\setcounter{secnumdepth}{3}
\chapter{Introduction}
In the last decades, a trend of dynamic programming languages \footnote{Not to be confused with \textit{dynamically typed programming languages.}} has been on the rise.
As opposed to static programming languages (usually compiled) dynamic ones offer a higher level of abstraction and allow faster and less error-prone development.
Dynamic languages move a lot of actions traditionally done during compile-time to run-time. This creates the need for another layer, \textit{a runtime environment}.

My goal in this diploma thesis is to implement a process virtual machine for a programming language called SOM, or Simple Object Machine. 
It is a dynamic, object-oriented programming language based on Smalltalk. It was originally implemented at University of Århus in Denmark to teach
object oriented VMs \cite{som-github}. There are several implementations in various programming languages, ranging in speed, optimizations etc.

My main focus in my work will be the clarity of implementation over performance. I will try to provide a basic implementation of a traditional runtime
VM that can be built upon in the future. This will include the process of parsing, compiling the bytecode and then providing a runtime environment,
along with an implementation for most basic principles (flow control, basic data types, loops).

\chapter{Analysis and design}
\textit{Simple Object Machine} (SOM) is a minimal Smalltalk dialect used primarily for teaching construction of virtual machines. Key characteristics
according to official website (\cite{som-github}) are:
\begin{itemize}
	\item clarity of implementation over performance,
	\item common language features such as: objects, classes, closures, non-local returns
	\item interpreter optimizations, threading, garbage collectors are different
		across various implementations.
\end{itemize}

\section{Grammar}
To implement a parser for the language, I decided to use ANTLR. I will demonstrate language features and design on the following ANTLR grammar
for SOM. For the sake of brevity, I ommited terminal symbols from the complete grammar as they are self-explanatory. All the terminal symbols
in this grammar are named in uppercase letters.

\begin{verbatim}
	grammar SOM;

	classDefinition:
		IDENTIFIER EQUALS superclass
		instanceFields method*
		(SEPARATOR classFields method*) ?
		CLOSE_PAR
	;
	superclass: IDENTIFIER? OPEN_PAR;
	instanceFields: (VBAR variable* VBAR)?;
	classFields: (VBAR variable* VBAR)?;
	method: pattern EQUALS methodBlock;
	methodBlock: OPEN_PAR blockContents? CLOSE_PAR;
	blockContents:
		(VBAR localDefinitions VBAR)?
		blockBody;
	localDefinitions: variable*;
	blockBody: 
		  RETURN result
		| expression (PERIOD blockBody?)?;
	result: expression PERIOD?;
	expression: assignation | evaluation;
	assignation: assignments evaluation;
	assignments: assignment+;
	assignment: variable ASSIGN;
	evaluation: primary messages?;
	primary: variable | nestedTerm | nestedBlock | literal;
	messages:
		  unaryMessage+ binaryMessage* keywordMessage?
		| binaryMessage+ keywordMessage?
		| keywordMessage;
	unaryMessage: IDENTIFIER;
	binaryMessage: binarySelector binaryOperand;
	binaryOperand: primary unaryMessage*;
	keywordMessage: (KEYWORD formula)+;
	formula: binaryOperand binaryMessage*;
	nestedTerm: OPEN_PAR expression CLOSE_PAR;
	nestedBlock:
		NEW_BLOCK blockPattern? blockContents? CLOSE_BLOCK;
	blockPattern: blockArgs VBAR;
	blockArgs: (COLON argument)+;
	variable: IDENTIFIER;
	pattern: unaryPattern | keywordPattern | binaryPattern;
	unaryPattern: unarySelector;
	unarySelector: IDENTIFIER;
	binaryPattern: binarySelector argument;
	keywordPattern: (KEYWORD argument)+;
	binarySelector: 
		VBAR | PLUS | MINUS | EQUALS | MULT | DIV | MOD |
		GREATER | GREATER_EQ | LESS | LESS_EQ;
	argument: variable;
	literal: literalNumber | literalString | literalArray | literalSymbol;
	literalNumber: MINUS? (INTEGER | DOUBLE);
	literalString: STRING;
	literalArray: POUND NEW_BLOCK literal* CLOSE_BLOCK;
	literalSymbol: POUND (STRING | selector);
	selector: binarySelector | keywordSelector | unarySelector;
	keywordSelector: KEYWORD+;
\end{verbatim}

\section{Class definition}
\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{media/grammar/classDefinition_rrd.png}
	\caption{Railroad diagram for \texttt{classDefinition} rule.}
	\label{fig:classDefinition_rrd}
\end{figure}

\begin{lstlisting}[language=Smalltalk]
	SimpleHello = (
		| name |

		setName: aString (
			name := aString
		)

		printGreeting (
			('Hello, ', name) print
		)
	)
\end{lstlisting}

Syntax for class definition follows the official SOM grammar. The language supports single inheritance as apparent from the use
of \texttt{subclass} token in the grammar. Not every class has explicitly specified superclass, therefore the actual identifier in
the rule is optional.

Declaration of instance side fields follows, denoted by vertical bars. This token itself can be empty. Instance side methods definitions
are next. Further details on \textit{methods} and \textit{messages} in SOM are discussed in TODO. % TODO: add a link to section on methods
Same syntax is used for class side fields and methods separated by a special token.

\subsection{Variables}
In Smalltalk, a variable is defined as \textit{``a dynamically modifiable association (binding) of either a name
or an index to a value. Each distinct variable has exactly one name (or index)''}\cite{smalltalk-essentials}.

A value of a named variable can be any object. Indexed variables are at the core also just an object. They
represent an ordered sequence of objects as a single value. Example of those are arrays or Strings. Actual
indices are always strictly positive (greater than zero), meaning the first element of an array corresponds
to index of value one. This is standard in Smalltalk dialects, although uncommon in C-like languages. Retrieving
the values belonging to an index is done via sending a message to the encapsualting object.



When creating a new variable, it is assigned a special value \texttt{nil}, meaning the variable is empty. This
special value can also be explicitly assigned to a variable at any point.

SOM is a dynamically typed programming language (as is Smalltalk). As a result, there is no syntax to indicate
a data type of a variable. One thing worth pointing out is that in the context of Smalltalk, a \textit{data type}
is defined differently than most programming languages. As stated in \cite{smalltalk-essentials}, a class is not
a type. A Smalltalk type is defined as \textit{``the power set of messages to which an object can meaningfully
respond''}\cite{smalltalk-essentials}. This is the definition I will be using in the context of SOM. As a result
of this, any number of SOM classes can implement one data type.

\subsubsection{Variable name scoping}
Every variable has its scope, which determines the visibility of the variable. SOM follows the rules of Smalltalk
when it comes to scoping, as defined in \cite{smalltalk-essentials}:

\begin{itemize}
	\item \textbf{Local variables} are accessible within the method or code block in which they are defined.
	\item \textbf{Formal method arguments} are accessible by the method wherein they are defined.
	\item \textbf{Formal block arguments} are accessible by the block wherein they are defined.
	\item \textbf{Instance variables} are accessible within all methods of a given object. Each object
		has its own instances of these variables.
	\item \textbf{Class variables} are accessible by all objects that are instances of the class or its
		subclasses. All the objects share the same instance of this variable.
	\item \textbf{Global variables} are accessible everywhere.
\end{itemize}

There is some more details on variable scoping, especially when talking about block closures. Further detail
is discussed in \ref{subsection:nlret}.

\subsection{Literals}
Outside of variables, there is also a need to represent fixed values in a SOM source code. 

\textbf{Integer literal} specifies a value of a decimal whole number, positive or negative.
In my implementation, every integer literal is a representation of an object of class \texttt{Integer}. 
To achieve simple manipulation with integer numbers, all integers are internally represented by a C++
data type \texttt{\detokenize{int32_t}} -- therefore 32 bit signed integer number. Overflow and underflow is not
addressed in my implementation, therefore the behaviour copies that of the underlying C++ type.

\textbf{Floating point literal} approximates a value of a real number. Syntactically, it consists of
a decimal, possibly negative, integer literal representing the non-fractional part of the number. It is
followed by a decimal point and another decimal (non-negative) integer representing the fractional part
of the number. Precision is implicitly given and there is no way to change it. My implementation uses
double precision (as defined in C++). Edge cases (such as rounding errors) are not addressed -- the behaviour
copies that of standard C++ double data type.

\textbf{String literal} represents a sequence of characters. String literals are objects of class \texttt{String}.
Syntactically, they are delimited by single quotes (\texttt{'}). To include a single quote in a string, it needs
to be escaped by another single quote.

In the provided implementation of SOM, String objects are not treated as a collection. It is an encapsulated object
and every String object is unmutable. Every message, that somehow uses and modifies the value of its receiver
creates a new object. This behaviour corresponds with Smalltalk and other SOM implementations.

\textbf{Array literals} specify a sequence of values encapsulated by a single object (that is an instance of class
\texttt{Array}). Syntactically, the values of an array are surrouned by parentheses and preceeded by a hash sign.
Note that because of the dynamic typing, elements of an array do not have to be instances of the same class.

Every Array literal results in an Array object instantiation. Arrays are mutable, unlike Strings.

\section{Primitives}
Even though SOM is purely object oriented, in order toto get any actual computations done, there is a point where
some virtual machine primitives must be invoked. Following things are therefore implemented as primitives:
\begin{itemize}
	\item memory allocation (\texttt{new} message),
	\item bitwise operations,
	\item integer arithmethics (\texttt{+}, \texttt{-}, \texttt{=} etc.),
	\item array accessing (\texttt{at:}, \texttt{at:put:})
\end{itemize}

Primitives are implemented directly in the VM runtime, though not breaking the syntax or core principles of the
language. Details on implementation are in section \nameref{subsection:primitives}.

\section{Methods and messages}
As the SOM language is based on Smalltalk, the concept of messages (and the link to methods) is crucial to understand.
\textit{``The only way to invoke a method is to send a message -- which necessarily involves dynamic binding
(by name) of message to method at runtime (and never at compile time). The internals of an object are not
externally accessible, ever -- the only way to access or modify an object's internal state is to send it
a message''} \cite{smalltalk-essentials}.

Execution of an invoked method ends with the execution of the last expression in it. Every method implicitly
returns \texttt{self} (a reference to the object on which the method is invoked). Explicit return of a value
is done with a special token \texttt{\^}. Execution of an expression preceeded by this token will exit the method.

The \cite{pharo-by-example} defines a helpful terminology for message passing:
\begin{itemize}
	\item A message is composed of the message \textit{selector} and the optional message arguments.
	\item Every message must be sent to its \textit{receiver}.
	\item Message and its receiver together will be referred to as \textit{message send}.
\end{itemize}

There are three types of messages (as defined in other Smalltalk dialects, Pharo as an example of one).

\textbf{Unary messages} are sent to an object without any additional information (argument). In the following
example, a unary message \texttt{size} is sent to a string object.
\begin{lstlisting}[language=Smalltalk]
	'hello' size "Evaluates to 5"
\end{lstlisting}

\textbf{Binary messages} are a special type of messages that require exactly one argument. The selector
of a binary message can only consist of a sequence of one or more characters from the set: +, -, *, /,
\&, =, \textless, \textgreater, |, ~ and @. A very simple example of usage of binary messsage are arithmetic operations.
\begin{lstlisting}[language=Smalltalk]
	3 + 4 "Evaluates to 7"
\end{lstlisting}

\textbf{Keyword messages} require one or more arguments. From the syntactic standpoint, they consist of
multiple keywords, each ending in colon (:). When sending a message, each keyword is followed by an argument.
Note, that a keyword message taking one argument is different to a binary message.
\begin{lstlisting}[language=Smalltalk]
	| numbers |
	numbers := #(1 2 3 4 5). "Simple array"
	"Sending a keyword message at:put: to an object of class Array"
	numbers at: 1 put: 6 "numbers is now #(6 2 3 4 5)"
\end{lstlisting}

When composing messages of various types, there are precedence rules (as defined for Pharo in \cite{pharo-by-example}):
\begin{itemize}
	\item Unary messages are sent first, followed by binary messages. Keyword messages are sent last.
	\item Messages in parentheses are sent before other messages.
	\item Messages of the same kind are evaluated from left to right. 
\end{itemize}

These simple rules permit a very natural way of sending messages, as demonstrated on the next example.
First, a simple array is created. Then, a unary message \texttt{last} is evaluated, returning the last
element of the array. After that, binary message \texttt{+} is evaluated (to 2 in this example). Finally,
keyword message \texttt{at:put:} is sent to an array, putting number 5 on the second position in an array.
\begin{lstlisting}[language=Smalltalk]
	| numbers |
	numbers := #(1 2 3 4 5).
	numbers at: 1 + 1 put: numbers last.
	"numbers at: (1 + 1) put: (numbers last)"
\end{lstlisting}

Next example demonstrates sending messages from left to right when all of them are of the same type.
\begin{lstlisting}[language=Smalltalk]
	| numbers |
	numbers := #(1 2 3 4 5)
	numbers last asString print
	"This is equivalent to the following message sends"
	((numbers last) asString) print
\end{lstlisting}

There is a downfall to the simplicity of these rules. Arithmethic operations are all just a simple binary
message sends, therefore to ensure proper precedence, it is necessary to use parentheses.

\section{Blocks}
Blocks provide a mechanism to defer the execution of expressions \cite{pharo-by-example}.
Blocks can be treated as an object -- they can be assigned to variables and
passed as arguments. 

Blocks can also accept parameters -- they are denoted with a leading colon. Parameters are separated from the body
of the block by a vertical bar. Local variables can also be declared inside a block. Those are accessible only inside
the block and are initialized each time a block is evaluated.

Block is executed by sending it a message \texttt{value}. However, this is a unary message and there is no way
to pass parameters to a block. To solve this problem, a keyword message \texttt{value:} is implemented. So far, this
gives a user to pass only one parameter to a block. To mitigate this issue, there are two posibilities. The first one
is to implement a keyword message for every number of parameters (for example \texttt{value:value:}, 
\texttt{value:value:value:}). While this approach is simple, readable and relatively easy to implement for low
numbers of parameters, it is impossible for this solution to be exhaustive and the code using very long keyword
messages would be bloated.

Another approach would be to implement a keyword message \texttt{value:} with an argument of array type. This would
permit to use arbitrary number of arguments, though it would require to create arrays of objects before passing them
to a block, which could impact readability and clarity of the code. In order to combine pros and cons of these 2
approaches, I have decided to follow the implementation in Pharo according to \cite[p.~65]{pharo-by-example}. 
There are keyword methods implemented for up to four parameters (\texttt{value:}, \texttt{value:value:}). For more
than four parameters, a special keyword message \texttt{valueWithArguments:} is implemented, where an array of
parameters is expected.

\begin{figure}
	\caption{Example of blocks usage in SOM.}
	\begin{lstlisting}[language=Smalltalk]
		| b0 b1 b2 b3 |
		b0 := [ 1 + 2 ].
		b1 := [ :x | x * x ].
		b2 := [ :x :y | x * y ].
		b3 := [ :x :y :z | x + y + z ].
		"Evaluating the blocks"
		b0 value. "Returns 3"
		b1 value: 3. "Returns 9"
		b2 value: 2 value: 8. "Returns 16"
		"Message valueWithArguments: can be used with any number of parameters"
		b3 valueWithArguments: #(1 2 3). "Returns 6
		"The next expression is functionally identical to the previous one"
		b3 value: 1 value: 2 value: 3.
	\end{lstlisting}
\end{figure}

\subsection{Non--local return and block scoping}
\label{subsection:nlret}
Block closures are an essential feature to SOM. They allow the implementation of conditionals and loops as messages
rather then them being baked in the language syntax. Blocks however bring some dynamic runtime semantics that is not
straightforward. When used to the extreme, blocks can introduce some confusion and generally ugly code. However when
used correctly, they offer great way to improve readability and reusability of the code.

Every method has its defined context -- a set of variables and objects accessible from the method at given point in an
execution. Variables accessible by blocks are bound during runtime, in the context of where the block is \textit{defined},
rather than executed. This is reflected in creation and handling of frames (which can be considered a representation of
the context of given method). This also ties in to how returns from blocks function.

The context in which the block is created (and evaluated) is commonly called as \textit{home context} of the block.
The block home context is basically a representation of a particular point in the program execution. When a return
statement is executed, the execution steps out of the current context and returns to the caller. This can be
an implicit return (every method or block implicitly returns the receiver of the message). User can decide to
return a different value, denoted by explicit return statement, (\texttt{\^} token).

The behaviour of explicit return in blocks is where the term non--local return comes in. \textit{Non local return returns
to the sender of the block home context, i.e., to the method execution point that called the one that created the block}
\cite{pharo-blocks}. The important thing is that the home context is tied to the creation of the block, not its
evaluation. The pitfall here is there can be a situation where home context of a block being evaluated could end before
the block attempts a return to it. This will result in runtime error.

To ilustrate the non local behaviour better, consider a following example.

\begin{lstlisting}[language=Smalltalk]

\end{lstlisting}

\section{Expressions}
According to \cite{smalltalk-essentials}, \textit{an expression is a segment of code in a body of executable code
that can be evaluated to yield a value as a result of its execution.} Expressions can contain another expressions.

\begin{figure}
	\begin{verbatim}
	expression: assignation | evaluation;
	assignation: assignments evaluation;
	assignments: assignment+;
	assignment: variable ASSIGN;
	evaluation: primary messages?;
	primary: variable | nestedTerm | nestedBlock | literal;
	messages:
		  unaryMessage+ binaryMessage* keywordMessage?
		| binaryMessage+ keywordMessage?
		| keywordMessage;
	\end{verbatim}
\end{figure}

Syntactically, an expression can consist of \cite{smalltalk-essentials}:
\begin{itemize}
	\item literal,
	\item variable/constant reference,
	\item message send,
	\item nested expression.
\end{itemize}

\section{Control structures}
In Smalltalk, there are no built-in control structures, unlike for example C++ or Java. SOM follows this principle
from Smalltalk, therefore there are no grammatical rules for branching or loops.

The way controlling the flow of program works in SOM is, again, by sending messages. One big advantage of this 
approach is that the programmer can define their own control structures, simply by implementing classes and
methods as needed.

To make working with SOM easier and faster, my implementation provides multiple message implementations, 
corresponding to the most used control structures in other programming languages. Syntax of these messages
corresponds to other Smalltalk dialects.

\subsection{Conditional branching}
There are 3 messages that function as an if control structure. Selectors for these messages are \texttt{ifTrue:},
\texttt{ifFalse:}, \texttt{ifTrue:ifFalse:}. As apparent, they are keyword messages, the receiver is an instance of
a Boolean class. All of these messages take blocks as arguments, then evaluating or not evaluating them based on
the Boolean value. Figure \ref{lst-if-control} shows a simple example of usage.

\begin{figure}[h!]
	\begin{lstlisting}[language=Smalltalk]
		"Subtracts b from a only if a is greater then b"
		a > b ifTrue: [ a - b ].
		a <= b ifFalse: [ a - b ].
		"Subtracts the smaller number from the bigger one"
		a < b
			ifTrue: [ b - a ]
			ifFalse: [ a - b ]
	\end{lstlisting}
	\caption{Example of messages functioning as \textit{if-}control structures.}
	\label{lst-if-control}
\end{figure}

\subsection{For loops}
The simplest example of a for loop is iterating over a range of integers. There are 2 messages, \texttt{to:do:} and  \texttt{to:by:do:}.
The receiver of the message is an integer. The receiver of the message is the lower bound of the iteration, the argument for \texttt{to:}
keyword is the upper bound, \texttt{by:} specifies a step of iteration, \texttt{do:} takes a block that is evaluated (note that the block
has to have exactly one parameter, so it is possible to capture the value of index in every step).

\begin{figure}[h!]
	\begin{lstlisting}[language=Smalltalk]
		"Prints all numbers from 1 to 10"
		1 to: 10 do: [ :index | index asString printLn ].
		"Prints all the even numbers between 1 and 100"
		0 to: 100 by: 2 do: [ :index | index asString printLn ]
	\end{lstlisting}
	\caption{Example of simple for loops.}
	\label{lst-for-index}
\end{figure}

This way of looping is also usable when iterating over arrays (or any indexable collection). As seen on figure \ref{lst-for-array}, this method is not
very concise, therefore a message \texttt{do:} is implemented. Array class implements a method corresponding to this message, iterating
over every element of the array. It takes a block as an argument. The block has to have one parameter -- that is the element of the array
of the given step of the iteration.

\begin{figure}[h!]
	\begin{lstlisting}[language=Smalltalk]
		| array |
		array := #(1 2 3).
		"Printing the elements by iterating over index"
		1 to: array size do: [ :index |
			(array at: index) asString printLn ].
		"Printing the elements by iterating over array"
		array do: [ :element | element asString printLn ]
	\end{lstlisting}
	\caption{Examples of different ways of iterating over an array.}
	\label{lst-for-array}
\end{figure}

\subsection{While loops}
While loops are implemented as a unary message sent to a block that returns a boolean value. There are actually
two messages, \texttt{whileTrue} and \texttt{whileFalse}. The first one repeats the evaluation of a receiver (a block)
as long as it returns \texttt{true}. The second one, as the name suggests, does the same thing if the block returns
\texttt{false} value. Example in figure \ref{lst-while} shows printing numbers from 0 to 10 using \texttt{whileTrue}
message.

\begin{figure}[h!]
	\begin{lstlisting}[language=Smalltalk]
		| index |
		index := 0.
		[ index asString printLn.
		index := index + 1.
		index < 10
		] whileTrue
	\end{lstlisting}
	\caption{Example of while loops.}
	\label{lst-while}
\end{figure}

\subsection{Class hierarchy}
SOM supports single inheritance and it is a vital aspect of the language. As a purely object-oriented programming language,
it takes full advantage of polymorphism.

Single inheritance permits only one superclass per class. The superclass can be explicitly defined. If it is not defined,
every class is a subclass of special Object class. This therefore means that every object is an instance of the Object class
or its subclass.

Tied with inheritance is a principle of late binding. The method to invoke is decided during runtime. The method lookup is simple
-- it follows the chain of inheritance, from the subclass to superclass (always ending at Object class). 

\section{Abstract syntax tree}

\section{Bytecode}
The next step after constructing the AST is to compile it into a bytecode. The bytecode is saved in a binary file that can be
interpreted. The structure of bytecode files and semantics and syntax of operation codes is described in the following sections.

\subsection{Program structure}
SOM program has a very simple structure consisting of:
\begin{enumerate}
	\item \textbf{The constant pool:} This is a list of all the entities of the program. The choice of the word \textit{entity}
		over \textit{object} is intentional to avoid confusion with what objects are in OOP languages. Each entity can be accessed
		by its index.
	\item \textbf{Entry point: } An index to a Method that is executed on program start. There can only be one entry point to a
		program. It is a unary method with selector \texttt{run}. It can be a member of any class of the program.  
\end{enumerate}

\subsection{Program entities}
All entities in the constant pool are one of these types:
\begin{enumerate}
	\item \textbf{Nil entity} represents an undefined value.
	\item \textbf{Int entity} represents a 32 bit signed integer number. It is used for LIT instrucions.
	\item \textbf{Double entity} represents a double-precision floating point number.
	\item \textbf{String entity} represents a value of string of characters of arbitrary length. It is used for
		constants in the program as well as to store all the identifiers to classes, method selectors and variables.
	\item \textbf{Field entity} represents a variable in an object. It consists of one index to a string value that represents
		the name of the slot.
	\item \textbf{Method entity} represents a method of an object. It holds and index to a string representing the selector,
		number of arguments (arity of the corresponding message), number of local variables and an array of instructions.
	\item \textbf{Primitive entity} is a method that needs an implementation in the VM. These are used to handle constructs that
		cannot be expressed in the base language. 
	\item \textbf{Block entity} is a block of code. It holds the number of arguments and an array of instructions (similar
		to a method).
	\item \textbf{Class entity} represents the structure of objects. It consists of an array of indices to all the fields
		of the object. Each one of these fields point either to a Field entity or a Method entity.
\end{enumerate}

\subsection{Instructions}
\begin{itemize}
	\item \texttt{LIT i} retrieves a constant value from the constant pool at the index \texttt{i} and pushes it
		on the stack. The item can be either integer, double or string value.
	\item \texttt{GET SLOT i} pops a value from the operand stack, assuming it is an object. Then it retrieves a value
		with index \texttt{i} from the constatns pool, assuming it is a string. It then retrieves the value
		stored in the slot with the name specified by the string and pushes it onto the stack.
	\item \texttt{SET SLOT i} pops a value from the stack. This value is then assigned to an instance variable with identifier
		at index \texttt{i} in the constants pool.
	\item \texttt{SEND i n} sends a message to an object, which in most cases results in calling a method. A new frame
		is created on the execution stack, arguments are pushed and the execution jumps to the first instruction of the
		method.
	\item \texttt{GET LOCAL i} retrieves a local variable with an index \texttt{i} and pushes it to the top of the stack.
	\item \texttt{SET LOCAL i} pops a value \texttt{x} from the top of the stack and then assignes the \texttt{x} into
		a local variable with the index \texttt{i}.
	\item \texttt{GET SELF} retrieves the callee of executed method. The object is pushed to the top of the stack.
	\item \texttt{GET ARG i} retrieves the i--th argument of the current message from the stack and pushes it on top.
	\item \texttt{BLOCK i} creates a code block object. The argument \texttt{i} points to a block value in the constant pool.
		The block object is instantiated on the heap and pushed to the top of the stack.
	\item \texttt{RET} is used to return from a method call. The value from the top of the stack is returned. The address
		to return to is retrieved from the current frame, then the frame is popped and execution jumps to an instruction
		after the \texttt{CALL} that invoked the method.
	\item \texttt{RETNL i} - non local return. The value at the top of the current frame is used as the return value. Argument
		\texttt{i} specifies the number of frames to be popped, then the return value is pushed to the top of the current frame.
\end{itemize}

\subsection{Garbage collection}
The process of \textit{garbage collection} performed by \textit{garbage collector (GC)} is the process of allocating and freeing
memory during application runtime. The main advantage of this mechanics is to prevent \textit{memory leaks} -- parts of a program
that allocate memory without freeing it when it is not needed \cite{memleaks-raygun}. Most modern high-level programming languages
implement some form of garbage collection.

There are multiple possible algorithms that solve this problem. I have decided to implement a mark and sweep algorithm, due to
its simplicity. The expectation is that this algorithm will not be particularly fast, though it leaves a lot of room for possible
improvements and it can be used as a demonstration of performance effects of a garbage collector.

\subsubsection{Mark and sweep}
According to \cite{gc-ms}, the algorithm consists of two main phases:
\begin{itemize}
	\item Mark phase -- discovery of all the reachable objects.
	\item Sweep phase -- clearing the heap of all unreachable objects.
\end{itemize}

Every object allocated on the heap holds a mark bit. This represents the reachability of the object -- 0 (false) for
unreachable, 1 (true) for reachable. Upon object creation, the mark bit is set to zero. In the sweep phase a simple
graph traversal algorithm can be used (such as DFS -- Depth First Search) to mark all the reachable objects. Every
objects can be considered a node and variables serve as neighbour lists. Root nodes would be local variable and fields
that are directly accessible.

In the sweep phase, the whole heap can be traversed linearly and objects with mark bit set to zero are deleted. As the \cite{gc-ms}
states, main advantages of this algorithm are:
\begin{itemize}
	\item algorithm handles cyclic references and therefore cannot end up in an infinite loop,
	\item no additional overheard during the execution of the algorithm (such as extra data structures etc.).
\end{itemize}

On the other hand, the simplicity of the algorithm means there are some disadvantages:
\begin{itemize}
	\item normal program execution is suspended during the garbage collection process,
	\item the algorithm does not address memory fragmentation.
\end{itemize}

The problem of memory fragmentation means that after several runs of the algorithm, the reachable objects will be separated
by chunks of free memory. This can be solved by shuffling the objects, though at a cost of further performance degradation.

To demonstrate the execution of the algorithm, consider the following object hierarchy allocated during a program execution.
Each node represents an object allocated on the heap, with marked bit set to false. Arrows represent variable references
from on object to another. In reality, there will be multiple root objects -- therefore the algorithm can run for every
root object.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{media/gc_ms_step1.png}
	\caption{Illustration of the object hierarchy before GC algorithm run.}
	\label{fig:gc_step1}
\end{figure}

The heap is then traversed from the root object (figure \ref{fig:gc_step2}). Each colour represents one step of the traversal. This example represents
breadth first search.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{media/gc_ms_step2color.png}
	\caption{Traversal of the heap objects.}
	\label{fig:gc_step2}
\end{figure}

After the run of the mark phase, all the objects reachable from the root objects (or multiple root objects after a run for each one) are marked.
One linear traversal over objects can then remove all of the unmarked ones (figure \ref{fig:gc_step3}).

\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth]{media/gc_ms_step3.png}
	\caption{State of the heap after the GC run.}
	\label{fig:gc_step3}
\end{figure}

\chapter{Realisation}

\section{Program overview}
The program I have implemented provides a way to compile SOM source code and execute it.

\begin{figure}[h!]
	\centering
	\begin{verbatim}
		<som_executable> [OPTION] [SOURCE]
	\end{verbatim}
	\caption{Interface of the program.}
	\label{fig:prog_interface}
\end{figure}

The interface of the application is simple and consists of two user provided arguments.

The argument \texttt{OPTION} can have two values and alters the mode the app will function in:
\begin{itemize}
	\item \texttt{-c} is compile mode. The argument \texttt{SOURCE} is a folder containing the source code of the program.
		This folder is searched for SOM source files -- those are recognized by their file extension, which should be \texttt{.som}.
		The folder is searched non recursively. Every SOM source file is compiled and one binary file containing bytecode is created.
		The name of the file is the same as the provided folder name.
	\item \texttt{-r} loads and runs a compiled bytecode. The \texttt{SOURCE} argument is a file name of the compiled bytecode.
\end{itemize}

\section{Abstract Syntax Tree}
After the parsing is complete, Abstract Syntax Tree (AST) is constructed. AST is, by definition, stripped of many syntactic detail.
It mainly represents the structural and content-related aspects of the code.

The conceptual design of the AST is depicted on figure \ref{fig:ast_class_concept}.

\begin{sidewaysfigure}[h!]
	\centering
	\includegraphics[width=\textwidth]{media/ast/ast_concept.png}
	\caption{Conceptual class diagram for SOM abstract syntax tree.}
	\label{fig:ast_class_concept}
\end{sidewaysfigure}

\subsection{AST Nodes}
\textbf{Class} node represents a class in the program, while the program itself is basically an array of different classes. A class
holds its name, its member fields (member variables in C++ terminology), instance-side methods (member functions), class-side fields
(static member variables) and class-side methods (static member functions).

\textbf{Method} node represents a method -- instance or class side. It consists of a pattern, local variable definitions and a block
to be executed.

\textbf{Pattern} represents a message corresponding to the method. There are 3 types of messages in SOM, therefore there are 3 distinct
types of patterns. The simplest one is \textbf{unary pattern} -- consisting of only one identifier as there are no arguments. \textbf{Binary pattern}
is treated as a separate pattern. It consists of identifier and exactly one argument. There are special requirments for binary pattern identifier
-- there is a special set of characters permitted that can form a binary pattern. \textbf{Keyword pattern} then consists of one or more keywords and
same number of arguments, each correpsonding to one keyword. Concatenation of keywords form a selector of the method. \textbf{Keywords} holds the string
value of the keyword, always ending in colon (:).

\textbf{Variable} node represents instance/class side variables, arguments to messages or blocks. It holds the identifier of the variable as a string value.

\textbf{Block} represents a block of executable code with its own scope. The simplest block consists of local variable definitions and an array of
expressions to be evaluated. While this is enough to represent a method block, other uses may require more information, therefore there is another
similar node discussed later.

\subsubsection{Expressions}
\textbf{Expression} is an abstract term in the context of the AST - there are two types. The common thing is they can be evaluated -- therefore forming
the actual executable code of the program. 

\textbf{Evaluation} is the first form of expression - it represents a message sends to an object, thus returning a single value when evaluated. This node
consists of messages (optional) and a \textit{primary}.

\textbf{Primary} is another abstract concept. In its core, a primary represents an object, though there are multiple ways to reference an object in SOM.
There are four AST nodes that can be classified as a primary:
\begin{itemize}
	\item \textbf{Literal} -- a constant basic value (of integer, floating point, string or array type). Each of these have their dedicated literal node
		holding the value as seen on figure TODO.
	\item \textbf{Variable} is self explanatory -- a reference to an object accessed via the identifier.
	\item \textbf{Nested term} is an expression that needs to be evaluated to retrieve the reference to an object. Syntactically, the nested terms
		are enclosed in parentheses.
	\item \textbf{Nested block} is a block of expressions returning the reference to an object. It is enclosed in square brackets in the syntax.
		Nested blocks consist of the same elements as block discussed with methods with addition of a block pattern -- nested block can have their arguments. %TODO: reference the section where blocks are discussed
\end{itemize}

The second part of the evaluation node is the message sends to the primary. There are three types corresponding to three types of messages in SOM.
\texttt{UnaryMessage} node is self explanatory -- there are no arguments, only the message selector. \texttt{BinaryMessage} holds its selector too
with addition of the argument. The argument of the binary message send can be a primary, along with unary message sends (because unary message sends take
precedence). \texttt{KeywordMessage} is made up of the keywords (forming the selector) and something called \textit{formulas}. Formulas are binary (and also unary) message
sends, that take precedence over keyword messages.

\textbf{Assignation} is the second form of an expression. The name suggests this node represents assigning a value into a variable. Therefore the node consists
of the \texttt{Variable} node to assign to and an \texttt{Evaluation} node returning the value to assign.

\subsection{AST construction}
The AST is constructed by visiting over the ANTLR--generated parse tree. The visitor is implemented in class \texttt{CParseTreeConverter}. This is a subclass
of \texttt{SOMParserBaseVisitor}, which is a base visitor implementation provided by ANTLR that perform depth--first traversal over the parse tree. Some member
functions in \texttt{CParseTreeConverter} are not overriden and make use of this default behaviour (which is just iterating over child nodes and visiting them).

\section{Bytecode}
After constructing the AST it is turned into a bytecode. The bytecode definitions are located in source files \texttt{Bytecode.h}/\texttt{Bytecode.cpp}. The actual
compilation is implemented as a depth--first traversal of the AST, therefore a visitor pattern is used. There is an abstract class \texttt{ASTVisitor} that defines
the interface of any AST visitor. This can be used to further implement visualisations of the AST or to add support for different bytecode instructions sets,
for example Java bytecode to add support for running inside a Java runtime.

\subsection{Values}
Every constant value in the code is saved as a \texttt{Value} struct. Each value contains the one byte tag and the actual value to hold. There are method implementations
to print every value into human readable format for better visualisation of the compiled bytecode. Additionally, every instruction struct is able to serialize itself -- 
write the data needed in binary format to a file.

\subsection{Instructions}
Similar to values, every instruction is represented by a struct holding the relevant information (such as operation codes and arguments). Every instruction is capable
of printing itself in human readable format and serialize itself to binary format, the same as all the values.

\section{Interpretation}
The process of interpreting the loaded bytecode is handled by class \texttt{CInterpret}. The class diagram of the interpretation environment is
in the figure \ref{fig:interpret_classDiagram}. The diagram serves as a reference point, all the parts are described in further detail in the
following sections.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{media/interpret_class.png}
	\caption{Conceptual class diagram for interpretation environment.}
	\label{fig:interpret_classDiagram}
\end{figure}

\subsection{Program counter}
The class \texttt{CProgramCounter} is an implementation for a program counter for the VM. During initialization of this object, the entry point of the program is loaded.
The program counter also saves the "end" address. The addresses are implemented as iterators to a vector of instructions -- that is possible simply because all of the
executable code will be contained within a method, and all the method are loaded into a vector of instructions. The entry point of the program is therefore the first
instruction of the \texttt{run} method, while "end" address is the end iterator of the same vector. This means that the end address is not an executable instruction.

\subsection{Execution stack}
The execution stack is responsible for management of method calls (and nested block evaluations). It is implemented as a LIFO (last in, first out) structure.
For every method call or block evaluation, a new frame is created and pushed on the stack. A frame contains:
\begin{itemize}
	\item Arguments accessible by their index, assigned at compilation. For the sake of stack, the callee is also considered an argument and is always
		the last element of the arguments array.
	\item Array of local variables, accessible by their index assigned during compilation.
	\item Return address. The program counter is set to this address when a \texttt{RET} instruction is executed.
	\item Local data for the method/block execution. This part is used for all the temporary object creation (e.g. literal values) and argument passing.
\end{itemize}

Sending a message or evaluating a block therefore can be split into multiple steps:
\begin{itemize}
	\item The receiver of the message is pushed to the stack.
	\item The arguments are then pushed to the stack, in the order from left to right.
	\item When the \texttt{SEND} instruction is executed, new stack frame is created. The return address is initialized to the address of the instruction
		following the \texttt{SEND} instruction. Array of arguments is initialized with the values from the top of the stack, number of arguments is provided
		as an argument of the instruction.
	\item The new frame is pushed to the stack. The receiver is then accessed, added to the end of the argument array and given the responsibility to invoke
		the method corresponding to the sent message.
\end{itemize}

When returning, the top of the stack contains the return value of the method or block. The frame is popped from the stack, program counter is set to the return
address and the top value is pushed to the new top of the stack.

\subsection{Objects}
Every object created during runtime (implicitly or explicitely) is represented by the \texttt{VMObject} class. Every value is represented by an instance of this
class or its subclass. Every object holds a pointer to its class and a map of the instance values -- the identifier as a key, object pointers as a value. Upon creation,
instance field values are initialize to the \texttt{nil} value.

Every class is represented by a \texttt{VMClass} instance, which is a subclass of \texttt{VMObject}. This allows us to manipulate every class as an object. There
is only one class instance per class definition during runtime and instantiating new class object is not possible. Before the execution of the code, the bytecode
is traversed and for every \texttt{CLASS} value, a singleton object is created and initialized. These objects are accessible globally by the identifier -- the class name.

Every class holds all the information needed to create and manipulate its instance. This includes the method dispatch.

\subsubsection{Object creation}
One of the main responsibilities of the class object is to handle dynamic creation of its instances. This is done via a \texttt{new} message send.
Upon the \texttt{new} message send:
\begin{itemize}
	\item new \texttt{VMObject} is created on the heap and its class is set,
	\item instance fields of the new object are initialized,
	\item pointer to the new object is returned.
\end{itemize}

\subsection{Core library}
SOM programming language is very light on features. In order for it to be usable, there needs to be an implementation of some fundamental principles provided.
For example, the language itself does not provide a way to manipulate numbers, character strings, standard input and output or control structures. All of these
can be implemented in the VM itself while preserving the consistency of rules of the language.

In order to achieve that, a keyword \texttt{primitive} is defined. This keyword is used for methods that require an implementation in the VM runtime. From the outside,
caling a primitive method is no different than calling a method implemented directly in SOM.

While the user is able to implement their own primitives, a lot of them are already provided in the core library. This library is a set of classes loaded every time
a SOM code is interpreted. This library provides implementations for:
\begin{itemize}
	\item strings,
	\item numbers -- integers and doubles,
	\item boolean values with messages that provided control flow features,
	\item code blocks,
	\item arrays.
\end{itemize}

\subsection{Primitives}
\label{subsection:primitives}
Every class that marks a method primitive has to provide its implementation in the VM. This is done by creating a new subclass of \texttt{VMClass}. This subclass
then has to implement the primitive methods (in the form of \texttt{void} member functions that take \texttt{CInterpret*} as an argument). Resolving of method
selector (which is a simple string) and the function to invoke is then done via member function \texttt{dispatchPrimitive}.

\subsubsection{Strings}
Every literal string value is represented by an instance of \texttt{String} class during runtime. The corresponding class implementing the primitives is
\texttt{VMClass}. In SOM, every string object is immutable, therefore every string manipulation results in creating a new string object.

This approach can however lead to inefficiencies when constructing strings. To combat this, a class handling dynamic string creation could
be implemented, similar to streams.

When looking at String implementation, there is a big difference to how they are implemented in SOM and Smalltalk. When a string object
is created in Smalltalk, it is handled as an object with indexed fields, each containing a character. My implementaion of SOM does not
conform to this, as strings are simply handled in the VM runtime. Possible extension of the language could be developed, allowing for
creation of objects with indexed fields.

This could be the applied to arrays, thus creating a unified ways to handle collections.

\subsection{Messages}
In SOM, almost everything is handled via message sends. Message sends invoke a method, implemented either directly in SOM, or as a primitive.
The process of invoking a method on an object depends on what kind of message is sent. Additionally, a small number of special cases needs to
be handled for code blocks, to allow for iteration.

When a \texttt{SEND} instruction is encountered, the receiver of the message is retrieved from the stack. As the receiver is pushed to the stack
first, before the argument, it needs to be retrieved using the message arity. To achieve the late binding, the selector (a string value)
is then retrieved from the constants pool. 

Reference to the class of the object than handles the method dispatch. Slight differences in method dispatch between primitives and native
methods are discussed in further detail in section TODO.

Every method invokation results in a new frame being created on the execution stack. Because the execution stack is implemented as a
stack of separate objects representing the frames (and not a continuous array), every new frame needs to be initialized. This handles
the argument passing, as well as scoping of local variables when sending messages to code blocks.

When the new frame is created, multiple actions take place:
\begin{itemize}
	\item Return address on the frame is set to the instruction following the \texttt{SEND} instruction. As every block of code must end
		with return (simple or non -- local), the existence of the address is guaranteed.
	\item The array of arguments is initialized. Arguments had been pushed to the stack in the order of corresponding keywords (therefore
		left to right). As a result, the arguments are reversed in the actual array -- member functions access them from the back. The
		last argument is set to the reciever -- that is the object accessed by \texttt{self} keyword (comparable to \texttt{this} pointer in
		C++).
	\item Array of local variable is initialized. This step is skipped for every object outside of code blocks -- instances of \texttt{Block}
		class. This is due to the scoping rules -- code blocks can access the local variables of the method, in which they are evaluated.
\end{itemize}

After the new stack frame is created, the execution of the method can take place. For primitive values, the corresponding member function
is called directly in the VM. For native methods, program counter is set to the address of the method and interpreting loop continues.

Method execution should always end with the return value at the top of the stack -- for primitives and native methods. Every method
should also end with the \texttt{RET} instruction. When this instruction is executed, the top value of the current stack is taken.
The top frame of the stack is removed, program counter is set to its return address and the top value is pushed to the top of the
underlying frame. Interpreting loop can then continue.

\subsection{Block evaluation}
From the outside, block evaluation is not very different to method execution. Actual work with blocks is also done entirely through
standard messaging system. To achieve the functionality in the implementation as -- is, some special cases need to be handled.

The block evaluation is done via \texttt{value} message (or the variants with arguments). The method itself is primitive, as full
access to interpreting objects is needed. 

As new frame is created on the stack on \texttt{value} send, the actual evaluation is done in that context. This provides one advantage
in the form of handling arguments -- the arguments provided to the message sends can be directly used by the actual block code, without
any modification. 

As per scoping rules defined in SOM, code blocks can access local variables of method that created them. However, every frame stack holds
its own local variables. For that, a special case is handled when sending messages to block (\texttt{value messages}, \texttt{whileTrue:} etc.).
The array of locals is first initialized with the values from the underlying stack. Every local variable of the block itself is then placed
after that. The block object itself (\texttt{self} in this scope) is at the end, as standard.

\subsubsection{Iteration}
To implement iteration easily and without the need for a lot of recursive calls, method \texttt{restart} is implemented for blocks.
This message restarts the execution of the block, without the need to call \texttt{self value}, which would result in a new frame
creation, along with possible arguments and local variables initialization.

In order for this method to work, every frame needs to hold a starting address of the corresponding method. Then the program counter
can be set to start of the block and executed again.
%TODO - some example would be nice

\setsecnumdepth{part}
\chapter{Conclusion}


\bibliographystyle{iso690}
\bibliography{mybibliographyfile}

\setsecnumdepth{all}
\appendix

\chapter{Acronyms}
% \printglossaries
\begin{description}
	\item[AST] Abstract syntax tree
	\item[GC] Garbage collector
	\item[SOM] Simple Object Machine 
	\item[VM] Virtual machine 
\end{description}


\chapter{Contents of enclosed CD}

%change appropriately

\begin{figure}
	\dirtree{%
		.1 readme.txt\DTcomment{the file with CD contents description}.
		.1 exe\DTcomment{the directory with executables}.
		.1 src\DTcomment{the directory of source codes}.
		.2 wbdcm\DTcomment{implementation sources}.
		.2 thesis\DTcomment{the directory of \LaTeX{} source codes of the thesis}.
		.1 text\DTcomment{the thesis text directory}.
		.2 thesis.pdf\DTcomment{the thesis text in PDF format}.
		.2 thesis.ps\DTcomment{the thesis text in PS format}.
	}
\end{figure}

\end{document}
